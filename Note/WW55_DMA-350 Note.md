## 3. DMA-350 概览

CoreLink DMA-350 是一款带有 AMBA® AXI5 接口的直接存储器访问控制器（DMAC）。1 它能够在多个通道上提供快速的存储器到存储器、外设到存储器、存储器到外设以及外设到外设的复制能力。

系统中的处理器可以通过 APB4 接口控制 DMA 通道行为，并在支持安全扩展（Security Extension）时设置安全相关参数。该 DMAC 针对不同类型的复制、离散-集中（scatter-gather）、增量或二维图像复制操作进行了配置。它还支持用于流控制和命令序列化能力的触发输入与输出。DMA-350 通过 LPI 接口增加了对时钟和电源低功耗集成的支持。

DMA-350 可以拥有多个通道，这些通道可以具有不同的属性（如 FIFO 大小）以适应不同的需求。通过命令链接（command linking）功能，可以将多条 DMA 命令组合在一起。利用命令链接功能，可以设置复杂的传输任务，且 DMAC 可以在无需处理器交互的情况下执行。每个 DMA 通道都可以拥有一个连接到外部数据处理单元（DPU）的流接口（AXI4-Stream）。在 DMAC 将数据写入目的地之前，这些通道可以对获取的数据执行所需的数据处理任务。

下图展示了系统中的 DMA-350：

![image.png|600](https://pic.lllincx.cn/20260105143202182.png)

### 3.1 组件概览

下图展示了 DMA-350 的顶层组件框图：

![image.png|600](https://pic.lllincx.cn/20260105144020746.png)

DMA-350 包含以下主要模块：

**Control（控制模块）**

- 接收并终止来自处理器的 APB4 总线。
- 将寄存器访问转发至各个通道。
- 实现 DMAC 的公共控制功能。
- 处理通道的安全（Security）与特权（Privilege）访问权限设置。
- 针对高层级 DMAC 事件产生中断。

**DMA Channel（DMA 通道模块）**

- 实现 DMA 控制器的一个功能单元，能够发起存储器传输。
- 根据当前命令的设置产生 AXI 传输。
- 终止来自外设的触发接口（Trigger Interface）。
- 针对通道内部事件产生中断和触发输出（Trigger Out）指示。
- 实现内部 FIFO，用于隔离通道的读写两侧。
- 支持通过 AXI4-Stream 接口连接外部数据处理单元（DPU）。
- DMA-350 中可存在多个 DMA 通道，具体数量由配置参数决定。

**BIU（总线接口单元）**

- 负责在 DMA 通道与一个或两个下游 AXI5 管理器（Manager）接口之间进行流量路由与仲裁。

**TRIG MTX（触发矩阵模块）**

- 在 DMA 通道的触发输入/输出端口与顶层触发输入/输出端口之间实现可选择的连接。
- 允许通道间进行内部触发。

**QCTRL（电源与时钟管理）**

- 实现 DMA-350 的时钟与电源管理特性。
- 终止 LPI 接口，并根据内部活动状态允许进入静默（Quiescence）状态。

## 3.2 合规性

DMA-350 接口符合以下 Arm 规范和协议：

- AMBA AXI5 协议，参见 AMBA® AXI and ACE Protocol Specification
- AMBA APB4 协议，参见 AMBA® APB Protocol Specification
- AMBA AXI4-Stream 协议，参见 AMBA® AXI-Stream Protocol Specification
- AMBA 低功耗接口（LPI）协议，参见 AMBA® Low Power Interface Specification

## 3.3 关键特性

DMA-350 支持以下关键特性：

- 可编程 APB4 配置寄存器
- AXI5 数据路径
- 用于时钟和电源的低功耗接口（LPI）
- 1-8 个并行 DMA 通道，每个通道带有可配置的 FIFO
- 包含地址增量的 1D 存储器复制
- 每个通道的中断能力及全局事件中断
- 灵活的命令链接（Command Linking）能力
- 用于流控制的触发能力
- 扩展存储器复制能力：2D/回环（Wrap）/模板（Template）
- 扩展接口

## 3.4 可配置选项

DMA-350 可以通过以下选项进行配置以满足特定的设计需求。括号内包含相关的配置参数，这些参数在 Arm® CoreLink™ DMA-350 Controller Configuration and Integration Manual 中有详细描述：

- AXI5 地址位宽：32 位或 64 位 (ADDR_WIDTH)
- AXI5 数据位宽：32 位、64 位或 128 位 (DATA_WIDTH)
- 通道识别寄存器位宽：0 位至 16 位 (CHID_WIDTH)
- 通道通用输出（GPO）位宽：0 位至 32 位 (GPO_WIDTH)
- 通道的 GPO 支持情况 (CH_GPO_MASK)
- 通道的 Stream 支持情况 (CH_STREAM_MASK)
- 每个通道独立的 FIFO 深度：1, 2, 4, 8, 16, 32, 64
- 通道的扩展特性支持（2D、回环、模板）(CH_EXT_FEAT_MASK)
- DMA 通道数量：1 至 8 个 (NUM_CHANNELS)
- 触发输入端口数量：0 至 32 个 (NUM_TRIGGER_IN)
- 触发输出端口数量：0 至 32 个 (NUM_TRIGGER_OUT)
- 触发输入端口同步 (TRIG_IN_SYNC_EN_MASK)
- 触发输出端口同步 (TRIG_OUT_SYNC_EN_MASK)
- 是否存在第二 AXI5 管理器端口 (AXI5_M1_PRESENT)
- 是否存在用于 TrustZone® 支持的安全扩展 (SECEXT_PRESENT)

# 4. DMAC 接口

本节包含 CoreLink DMA-350 接口的概览。

## 4.1 时钟与复位

DMA-350 旨在放置在单一时钟和复位域中。

APB4 配置接口和 AXI5 管理器接口（M0 和 M1）使用时钟使能信号，以支持这些接口在分频频率下运行。APB 配置接口使用 pclken 信号，M0 接口使用 aclken_m0 信号，M1 接口使用 aclken_m1 信号。

可选的 AXI4-Stream 管理器和从属接口没有时钟使能信号，它们直接使用模块时钟。

DMA-350 使用单一的低电平有效复位信号 resetn。该复位必须与 clk 时钟信号同步释放，但可以异步置位。

DMA-350 没有定义特殊的上电要求。

## 4.2 APB4 从机接口

APB4 从机接口用于访问 DMA-350 的内部配置寄存器。

DMA-350 支持 AMBA APB4 协议规范。有关更多信息，请参见 AMBA® APB Protocol Specification 文档。

寄存器访问

仅支持 32 位宽度的访问。当 APB4 写访问使用的 pstrb 不是 4'b1111 时，会导致错误响应。非对齐访问通过在内部将 paddr[1:0] 固定为 0，从而被视为正常访问。

### 4.2.1 APB4 保护

APB4 寄存器空间中的某些寄存器受保护，仅供高特权级和安全软件模块使用。这些寄存器配置 DMAC 的整体行为，并通过检查访问的特权和安全属性在 DMAC 内部受到保护。

特权保护

在访问具有更高特权权利的寄存器时，DMAC 会检查 pprot[0] 位。当访问被拒绝时，DMAC 返回 RAZ/WI。

安全保护

通过在访问具有更高安全权利的寄存器时检查 pprot[1]，DMAC 支持安全扩展（Security Extension）。当访问违反安全规定时，DMAC 根据软件配置寄存器返回 RAZ/WI 或错误响应，并且如果使能了中断，还可能产生中断。

### 4.2.2 APB4 PWAKEUP

APB4 接口通过 **pwakeup** 端口扩展了时钟唤醒信号。当 **pwakeup** 源自寄存器源时，这允许更快的时钟请求机制。该信号用于指示存在与 APB4 接口相关的持续活动。如果该信号不是 APB4 接口的一部分，可以将 **psel** 信号寄存化以生成 **pwakeup** 信号。

### 4.2.3 APB4 PDEBUG

APB4 接口具有一个侧带信号，允许调试器在非安全模式下扫描内存范围时访问 DMAC 而不产生副作用。当调试器发起 APB4 访问时，可以将此信号置高，从而禁用安全违规错误和中断生成，同时通过响应 RAZ/WI 继续保护安全寄存器。该信号在访问的 2 个周期内必须保持稳定。

## 4.3 AXI5 管理器接口

DMAC 是一个 AXI5 管理器，符合 AMBA AXI5 协议，具有缩减的 AXI5 特性集。有关协议的详细信息，请参见 AMBA® AXI and ACE Protocol Specification。AXI5 管理器接口用于由 DMA 通道生成的读写数据传输。

DMAC 上始终存在一个 AXI5 管理器接口。还可以通过使用配置参数 AXI5_M1_PRESENT 添加一个额外的 AXI5 接口。

### 4.3.1 突发类型（仅限 FIXED / INCR）

DMA-350 通过仅发送 FIXED 和 INCR 突发来降低复杂度。

FIXED 突发用于目标是带有 FIFO 的外设且多次访问同一地址的情况。这可以通过将增量值设置为 0 来实现。

INCR 突发用于所有其他情况，且突发长度受 \*MAXBURSTLEN 寄存器设置限制。如果 DMAC 在某些点连接到 AHB 互连，这也能降低将 AXI5 传输转换为 AHB 的复杂度。

### 4.3.2 ID 生成

**AxID** 的生成由 DMAC 按通道自动完成。读写传输使用标识通道的 **AxID**。命令链接也使用通道自身的 ID 从存储器中获取命令，但带有一个指示命令访问的额外侧带信号。可以通过使用 **CHID** 寄存器添加基于软件的通道 ID 设置，以辅助 DMAC 外部的内存映射。这些寄存器作为用户信号（User signals）存在于总线上，DMAC 内部不使用它们。

### 4.3.3 W 传输生成

**WDATA** 在 **AW** 通道传输的同时或之后发送到总线上。**WDATA** 不会赶超（overtake） **AW** 控制信息，因为这会增加仲裁逻辑的复杂度。如果传输大小设置为小于总线数据宽度，则使用 **Strobe**（选通）信号。

### 4.3.4 发起能力

读发起能力受每个通道独立 FIFO 深度的限制，可选值为 1, 2, 4, 8, 16, 32, 64。通道只有在有足够空间存储完整的读响应时才会发起读操作。

写发起能力取决于传输大小和存储在通道内部 FIFO 中的数据。当 FIFO 包含带有所有节（beats）的完整突发时，发起写操作。

发起的传输数量取决于命令类型和地址对齐情况。

最大发起能力受 DMA 单元限制，以避免 AXI 基础设施因过多的在途（outstanding）传输而过载。软件可以控制总线上的在途传输数量。如果总线仍然过载，这可以实现调试和总线利用率整形。

### 4.3.5 响应处理

AXI 访问可能导致成功或不同的错误响应。错误响应会被路由到特定通道，该通道进入错误状态，而其他通道继续运行。

### 4.3.6 AXI 带宽利用率

本节提供术语定义和优化要求。

**术语定义**

突发断点 (Burst breakpoint)

AXI5 突发不能跨越的边界。这些边界可以是以下内容：

- **1KB 地址边界**：DMA-350 绝不跨越 1KB 地址边界（支持 AHB 要求）。
- **触发块结束**：流触发请求允许访问一个触发块。一旦访问完成，需要新的触发请求才能访问任何后续数据，因此 AXI5 突发不能超出触发块。
- **FIFO 大小/2**：限制单次突发传输的数据量。
- **MAXBURST 寄存器设置**：限制突发长度（**axlen**）：突发必须短于此用户指定值。

非对齐起始 (Unaligned start)

AXI5 事务访问的第一个字节不是总线的 LSB 字节通道。

非对齐结束 (Unaligned end)

AXI5 事务访问的最后一个字节不是总线的 MSB 字节通道。

DMA-350 有两种模式来确定其 AXI5 突发节的大小（**axsize**）：

未优化 (Unoptimized)

无论总线宽度如何，节大小与 DMA 命令中设置的大小相同。

优化 (Optimized)

为了优化窄传输的总线利用率，在可能的情况下将它们分组为更宽的访问。AXI5 协议规范为读侧和写侧提供了不同的可能性。

- 对于写侧，节大小与总线宽度相同，使用写选通（write strobes）从写操作中排除未访问的字节通道。
- 对于读侧，对于具有对齐结束的 AXI5 事务，节大小与总线宽度相同。具有非对齐结束的 AXI5 事务可能只能部分优化。参见“非对齐起始地址示例”和“非对齐结束地址示例”中的示例。

**优化要求**

- AXI5 突发目标必须是 **Normal Memory** 类型（非 Device 类型）。
- 当前侧的当前 DMA 命令必须禁用 **Template** 特性。
- 当前侧的当前 DMA 命令的地址增量必须为 1。
- 读操作：
  - AXI 事务要么包含足够的数据以达到总线对齐，要么具有对齐的起始地址。
  - 如果起始地址对齐，但数据不足以访问总线上的所有字节，则使用在 DMA 命令定义的地址空间内最大的可能 **arsize**。

### 4.3.9 传输属性

传输的存储器属性（Memory attributes）可以通过每个命令的软件可配置寄存器进行调整。安全和特权设置可以针对安全或特权通道进行调整。读侧和写侧可以分别选择设备（Device）或存储器（Memory）类型。缓存策略（Cacheability）和共享属性（Shareability）值也可以进行设置，以匹配 DMA 传输目标内存位置的设置。这些设置必须与系统中其他组件定义的值相匹配，并会影响每次传输的性能。

与命令链接（Command link）相关的读取始终作为指令类型传输发送，即 `arprot[2]` 驱动为 1。命令链接访问继承通道的安全和特权设置。

### 4.3.10 额外 AXI 信号

AXI 支持多种对 DMAC 运行而言可选的特性：

- **axsize** 信号受数据总线宽度的最大值限制，因此如果 DMAC 驱动的是 64 位或更窄的总线，则可能不会使用最高有效位（MSB）。
- 不使用 **axlock** 信号，因为 DMAC 不会生成独占（exclusive）或锁定（locked）传输。
- **axinner** 信号指示读写事务的内部域（inner domain）缓存属性。
- **axchid** 和 **axchidvalid** 信号指示软件可配置的通道 ID。
- **arcmdlink** 信号指示当前的读操作是命令链接读取。
- **awakeup** 信号在两个管理器接口上均由寄存器驱动，用于唤醒 AXI 数据路径中的设备。
- **axdomain** 信号增加了最小限度的 ACE5-Lite 兼容性。

### 4.3.11 可配置的第二 AXI5 端口

当通过配置参数启用时，DMA-350 支持一个额外的完整 AXI5 管理器端口。这使得连接到系统的其他部分更加容易，而无需互连矩阵（Interconnect）。次要端口还允许在两个接口上并行进行读写操作。

两个 AXI5 管理器端口使用相同的属性，例如数据宽度和发起能力。两个端口都与模块时钟同步，同时拥有各自的时钟使能信号。

当使用两个 AXI5 管理器端口时，DMA-350 必须能够根据给定的地址决定应将其转发到 `AXI5_M0` 还是 `AXI5_M1` 管理器端口。在一个实现者可编辑的文件中提供了一个用于此目的的 SystemVerilog 函数。交付的 IP 包中包含了一个用于此目的的示例文件。

有关详细信息，请参阅《Arm® CoreLink™ DMA-350 控制器配置与集成手册》中的 AXI5 管理器端口地址映射章节。

## 4.4 触发接口

触发接口（Trigger Interfaces）可用于控制 DMA 通道操作与其他外设之间的交互。

外部外设或设备可以通过触发输入接口控制 DMA 命令的执行。DMAC 也可以通过其触发输出接口控制外部外设。

触发输入和触发输出接口相互兼容。由于这种兼容性，也可以在 DMAC 内部将两个 DMA 通道连接在一起，或者通过串联多个 DMA 控制器进行连接。

除了硬件触发接口外，还通过通道控制寄存器提供软件触发接口，使软件能够与触发机制进行交互。

### 4.4.1 触发输入接口

触发输入接口可以同步 DMA 命令与外设的操作。外设可以在命令或命令的一部分可以开始时通知 DMA-350。

该接口由简单的四相握手（4-phase handshake）以及定义当前请求和确认对类型的附加限定符总线信号组成。该接口定义为易于与现有的触发接口类型兼容。当接口跨不同的异步时钟域使用时，四相握手还允许简单的时钟域切换（CDC）结构。

### 4.4.2 触发输入接口信号

当外设将 **req** 信号拉高时，表示 DMAC 可以开始其命令或命令的一部分。DMAC 通过将 **ack** 置高来确认收到 **req**。

**req** 和 **ack** 信号都带有附加的限定符信号。这些信号为接收实体提供额外信息。

利用 **reqtype[1:0]** 信号，外设可以向 DMA-350 提供更详细的信息。DMAC 使用 **acktype[1:0]** 信号在发送 **ack** 的同时向外设提供更多信息。

### 4.4.3 触发输出接口

触发输出接口可以通知连接的外设 DMA-350 已完成一项命令。

该接口由简单的四相握手组成。该接口定义为易于与现有的触发接口类型兼容。当接口在不同的异步时钟域上使用时，四相握手还允许简单的时钟域切换结构。

### 4.4.4 触发输出接口信号

DMA-350 通过将 **req** 信号拉高，向外部外设发出命令已达到最终状态的信号。外设必须通过将 **ack** 信号拉高来确认收到此信息。在收到此确认之前，DMA 命令的执行尚未完成，这为 DMA-350 和外设之间提供了一个同步点。

## 4.5 AXI4-Stream 接口

每个 DMA 通道都可以拥有一个专用的 AXI4-Stream 接口，以使外部引擎能够对通过 DMAC 传输的数据进行处理。启用后，在 AXI 上读取的所有数据都会被推送到 Stream 接口。外部引擎预计会进行数据处理，处理结果可能是消耗数据、保持相同数据量、甚至生成更多数据元素。转换完成后，数据通过 Stream 输入接口发回 DMAC，并最终在 AXI 写侧写出。

Stream 接口预计将简单地连接到外部引擎，因此不涉及互连相关的侧带信号或空传输。Stream 接口符合 AMBA® AXI-Stream 协议规范，并使用数据传输所需的 AXI4-Stream 信号缩减集。

限制与扩展

接口数据宽度与 AXI 读写通道的数据宽度匹配，这意味着转换可以在 DMAC 外部完成。Stream 接口还支持连续的对齐和非对齐流。DMAC 不会发送稀疏流（sparse streams），也不接受从外部引擎接收的稀疏流。除断言 tlast 时外，tstrb 信号必须全部为 f，这限制了非对齐流仅在末尾拥有选通信号。

不支持空字节（Null bytes），接口上不存在 **tkeep** 信号。

在 `stream_in` 接口上存在一个额外的 **flush** 侧带输出信号。由于命令提前结束，该信号作为一个提示，要求外部引擎提供 **TLAST**。

## 4.6 LPI 接口

DMAC 通过用于时钟和电源的 LPI 接口增加对低功耗集成的支持。Q-Channel 接口为时钟提供静默（quiescence）能力，P-Channel 接口在 DMAC 处于空闲（IDLE）且无活动进行时允许进行电源管理。DMAC 可以通过活动指示信号请求电源和时钟。DMAC 根据其当前的内部状态接受或拒绝电源和时钟控制器的请求。

### 4.6.1 LPI 电源 P-Channel

电源 P-Channel 接口用于向 DMAC 请求电源静默。电源控制器驱动请求，而 DMAC 根据其当前内部状态接受或拒绝请求。DMAC 还可以通过 **pactive** 信号为某项活动请求电源。**pactive** 支持从“关闭（Off）”到“热复位（Warm reset）”的 10 位位宽活动指示。然而，DMAC 仅断言“关闭”、“全保持模式（Full retention mode）”和“开启（On）”指示。

DMAC 不旨在支持强制电源关断。当发生请求且活动正在进行时，DMAC 只是简单地拒绝请求并继续运行。除 P-Channel 握手外，该请求对操作没有影响。

### 4.6.2 LPI 时钟 Q-Channel

时钟 Q-Channel 接口用于向 DMAC 请求时钟静默。时钟控制器驱动请求，而 DMAC 根据其当前内部状态接受或拒绝请求。DMAC 还可以通过 **qactive** 信号为某项活动请求时钟。

DMAC 不旨在支持强制时钟关闭。当发生请求且活动正在进行时，DMAC 只是简单地拒绝请求并继续运行。除 Q-Channel 握手外，该请求对操作没有影响。

## 4.7 DMA 中断

中断指示 DMA 通道以及 DMA 单元内部状态的变化。每个通道都有自己独立的中断。始终存在一个全局非安全中断，此外，当启用 TrustZone 支持时，还会出现一个全局安全中断和一个安全违规中断。中断是电平触发信号。

## 4.8 控制与状态接口

控制与状态接口使系统能够控制 DMAC 的运行（停止和暂停），并提供 DMAC 运行的状态信息。

### 4.8.1 通用输出

通用输出（GPO）端口提供了额外的位，您可以在整个 DMAC 运行过程中将其设置为稳定值。

您可以将 GPO 端口用于多种用途：

- 选择内存银行（Memory banks）
- 在调试引脚上指示通道运行
- 控制外部数据处理引擎等。

GPO 是按通道驱动的，因此每个通道都有自己的端口。

GPO 的值由软件控制。当 `ENABLE` 寄存器位置位时，输出值变为有效，并在 DMA 通道处于激活状态时保持稳定。当通道停止驱动 GPO 时，GPO 保持在命令设置的最后一个值。通过运行一个选择所有 GPO 并将其清零的空命令，可以将 GPO 设回初始值。

### 4.8.2 停止与暂停控制

**allch_stop** 信号可被外部硬件单元用于停止 DMAC 所有激活通道的运行。在处理系统中的错误情况且必须通过立即行动清除 DMAC 任务时，停止功能非常有用。停止操作会等待所有读写事务的在途（outstanding）响应，但它会通过不再发送更多请求且不再断言触发信号，尝试尽快结束通道操作。

这些信号由简单的四相握手组成。当 **allch_stop_req_nonsec** 被断言时，所有未处于空闲状态的非安全通道都会停止。软件可以启用通道，但当此请求被断言时，它们会立即停止。**allch_stop_ack_nonsec** 的断言表示所有非安全通道均已停止或处于不活跃状态。当启用安全选项（`SECEXT_PRESENT=1`）时，对于安全通道存在独立的信号 **allch_stop_req_sec** 和 **allch_stop_ack_sec**，它们仅作用于安全域中的通道。

通过由外部硬件单元操作的 **allch_pause** 信号，可以在某个时间点立即暂停 DMA 通道的运行。暂停功能对于将通道冻结在某种状态并检查其寄存器的当前值，或者暂停 DMA 单元片刻以释放总线基础设施资源非常有用。使能位保持断言状态，并且每个传输和触发状态都得到保留，不会丢失任何信息。

这些信号由简单的四相握手组成。当 **allch_pause_req_nonsec** 被断言时，所有未处于空闲状态的非安全通道都会暂停。软件可以启用通道，但当此请求被断言时，它们会立即暂停。当请求撤销（deasserted）时，运行继续。当 **allch_pause_ack_nonsec** 被断言时，所有非安全通道均已暂停或处于不活跃状态。当启用安全选项（`SECEXT_PRESENT=1`）时，对于安全通道存在独立的信号 **allch_pause_req_sec** 和 **allch_pause_ack_sec**。

### 4.8.3 CTI（交叉触发接口）

允许一次性暂停和恢复所有通道。在为了调试目的而挂起处理器且调试器必须保存实际内存内容的系统中，CTI 是必需的，因此也可以暂停 DMAC 以避免损坏系统的当前状态。

该接口由挂起请求（**halt_req**）、重启请求（**restart_req**）以及显示 DMAC 是否已挂起的状态信号（**halted**）组成。

### 4.8.4 状态信号

这些信号指示各个通道的不同状态：

- **ch_enabled** 显示通道何时处于激活状态
- **ch_err** 显示通道何时遇到错误
- **ch_stopped** 显示通道何时被停止
- **ch_paused** 显示通道何时被暂停
- **ch_priv** 显示通道的特权设置
- **ch_nonsec** 显示通道的安全设置

## 4.9 配置接口

DMAC 的行为可以通过静态输入端口进行配置。静态输入端口来自于固定电平（tie-off）信号，或者由在 DMAC 释放复位时稳定且包含有效值的配置寄存器驱动。

### 4.9.1 自动启动接口

启动（boot）接口由以下信号组成：

- **boot_en** - 用于启用自动启动
- **boot_addr** - 启动命令描述符的地址
- **boot_memattr** - 获取启动命令描述符期间要使用的 AXI 存储器属性
- **boot_shareattr** - 获取启动命令描述符期间要使用的 AXI 存储器共享属性

- **boot_en** 的断言表示启用了自动启动且其他信号有效。
- 如果 **boot_en** 未被断言，则禁用自动启动且忽略其他启动信号。
- 所有启动信号在撤销复位时必须保持稳定，并保持稳定直到开始获取启动命令。

# 5. DMAC 运行

本节包含 CoreLink DMA-350 运行的概览。

## 5.1 DMAC 运行概览

DMAC 可以通过寄存器写入进行配置，以执行各种命令。当软件完成寄存器设置和命令链接元素后，可以通过额外的寄存器写入来使能通道。这一步会使所有配置寄存器在软件侧变为只读。随后，DMAC 开始检查命令的有效性，并根据寄存器设置执行传输。

命令可以包含简单的存储器传输、离散-集中型（scatter-gather）传输、触发处理、通用输出、2D 存储器操作以及许多其他组合。当命令执行完毕时，DMAC 要么返回空闲状态，要么重新加载该命令，或者跳转到命令列表中的下一个项目。当 DMAC 返回空闲（IDLE）状态时，它可以产生中断和触发输出信号，以便将此事件与系统中的软件或其他硬件元件同步。当 DMAC 处于空闲状态时，可以再次配置寄存器。

DMAC 还具备检测存储器传输期间错误的能力。当接收到故障时，它会返回错误并停止运行。

## 5.2 DMAC 运行基本命令

本节包含 DMA-350 运行基本命令的概览。

### 传输类型 1D

传输类型 1D 是一种一维数据块传输。它按照配置的传输大小（Transfer size），将数据从源地址连续传输到目的地址。此模式是大块数据传输的典型用例，在 DMAC 传输过程中不需要进行数据格式化。

传输大小设置范围从字节到总线宽度，按 2 的幂次方递增。源端和目的端的传输大小相同。源地址和目的地址与传输大小对齐，因为根据 **TRANSIZE** 的值，低位地址位会在内部被忽略。要复制的传输数量以传输大小的增量来指定。软件还可以限制 DMAC 发送到总线的最大突发长度（Maximum burst length），以允许互连上的其他设备进行仲裁。

![image.png|600](https://pic.lllincx.cn/20260119150218093.png)

| **参数名称**          | **寄存器映射条目**                 | **描述**                                                                                                                       |
| --------------------- | ---------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **源地址**            | `CH(x)_SRCADDR`                    | 传输数据的起始源地址。源地址必须与传输位宽对齐。                                                                               |
| **目的地址**          | `CH(x)_DESADDR`                    | 传输数据的起始目的地址。目的地址必须与传输位宽对齐。                                                                           |
| **源 X 长度**         | `CH(x)_XSIZE.SRCXSIZE`             | X 维度的源传输次数。源传输的宽度等于源传输的 `TRANSIZE` 值。                                                                   |
| **目的 X 长度**       | `CH(x)_XSIZE.DESXSIZE`             | X 维度的目的传输次数。目的传输的宽度等于目的传输的 `TRANSIZE` 值。                                                             |
| **传输位宽**          | `CH(x)_CTRL.TRANSIZE`              | DMAC 操作中源端和目的端共同使用的数据位宽。                                                                                    |
| **优先级**            | `CH(x)_CTRL.PRIORITY`              | 该信号作为 `AxQOS` 传递给 AXI 总线，用于通道间的仲裁。                                                                         |
| **源最大突发长度**    | `CH(x)_SRCTRANSCFG.SRCMAXBURSTLEN` | DMAC 操作源端支持的最大突发长度（Burst Length）。                                                                              |
| **目的最大突发长度**  | `CH(x)_DESTRANSCFG.DESMAXBURSTLEN` | DMAC 操作目的端支持的最大突发长度（Burst Length）。                                                                            |
| **源 AXI 传输属性**   | `CH(x)_SRCTRANSCFG.SRCTRP`         | **源传输属性**：包括内存类型、共享属性、安全属性和特权属性，从而决定 `arprot`、`arcache`、`ardomain` 和 `arinner` 信号的值。   |
| **目的 AXI 传输属性** | `CH(x)_DESTRANSCFG.DESTRP`         | **目的传输属性**：包括内存类型、共享属性、安全属性和特权属性，从而决定 `awprot`、`awcache`、`awdomain` 和 `awinner` 信号的值。 |
| **1D 回绕类型**       | `CH(x)_CTRL.XTYPE`                 | 决定在源和目的 X 长度不等时如何处理 1D 传输。                                                                                  |
| **填充值**            | `CH(x)_FILLVAL`                    | 特殊回绕情况下的填充值。当目的 X 长度大于源 X 长度时，剩余地址范围将填充该预定义值。                                           |
| **源地址增量**        | `CH(x)_XADDRINC.SRCXADDRINC`       | 用于计算源端地址的增量。增量计算公式为：`TRANSIZE * SRCXADDRINC`。                                                             |
| **目的地址增量**      | `CH(x)_XADDRINC.DESXADDRINC`       | 用于计算目的端地址的增量。增量计算公式为：`TRANSIZE * DESXADDRINC`。                                                           |

#### 5.2.1 1D 操作模式

WRAP 功能（1D 回绕类型）通过支持不同的源端和目的端内存大小扩展了 1D 传输。这允许将相同的数据多次拷贝到目的位置，或使用默认模式填充特定区域。

图中展示了不同的模式，其中 **L** 表示源数据块的最后一项。

当 1D 操作使用 WRAP 模式时，`XTYPE` 设置定义了 DMAC 将源数据拷贝到目的端时的行为。选项如下：

**wrap mode（回绕模式）**

- continue
  禁用单行内回绕，仅用于 2D 场景。DESXSIZE 被忽略。1D 操作类型：1Dbasic。
- wrap
  启用回绕，源数据会被多次拷贝到目的端。1D 操作类型：1Dwrap。
- fill
  启用填充，当源数据耗尽时，目的端将使用预定义模式进行填充。1D 操作类型：1Dfill。

#### 5.2.2 1D WRAP 情况列表

1D WRAP 传输可能出现以下几种情况：

**SRCXSIZE == 0, DESXSIZE == 0** DMAC 传输不启动。可能仅处于等待触发信号的状态。

**SRCXSIZE == 0, DESXSIZE > 0** 根据回绕类型（wrap type）的选择，行为如下：

- **continue, wrap**：无事发生，不执行读或写操作。
- **fill**：目的端填充预定义的填充值（fill value），因此仅发生写操作。

**SRCXSIZE > 0, DESXSIZE == 0** 根据回绕类型的选择，行为如下：

- **continue, wrap, fill**：不发生写操作。DMAC 仅发送 `SRCXSIZE` 次数的读传输。这通常用于流式接口（streaming interface），读取数据后通过流输出端口推送。

**SRCXSIZE == DESXSIZE** 无论 `XTYPE` 设置为何值，本质上都是标准的 1D 操作。

**SRCXSIZE > DESXSIZE** 根据回绕类型的选择，行为如下：

- **continue, wrap, fill**：由于目的端没有足够空间容纳源内存内容，当目的端范围填满时拷贝停止。**不会发生覆盖（overwrites）**，多余的数据在 DMAC 内部被丢弃。

---

SRCXSIZE < DESXSIZE 根据回绕类型的选择，行为如下：

- **continue**：当源端数据耗尽时，DMAC 停止数据拷贝。执行 `SRCXSIZE` 次数的读操作和写操作。
- **wrap**：当到达源数据末尾时，源地址计数器跳转回原始起始地址，并开始将相同的源数据拷贝到所有必要的目的内存位置。在整个回绕操作期间，源内存位置会被多次读取，因此源数据需保持不变（使用流接口时除外）。即使 `SRCXSIZE` 较小，本质上也会执行 `DESXSIZE` 次数的读和写。
  - _注意：单凭 `SRCXSIZE` 和 `SRCADDR` 的状态无法确定已执行的读取次数，必须根据 `DESXSIZE` 和 `DESADDR` 的进度来计算。_
- **fill**：向所有剩余的目的位置插入填充值。填充值由额外寄存器定义，并使用对应的传输位宽部分。读操作次数等于 `SRCXSIZE`，填充值在 DMAC 内部生成，总计产生 `DESXSIZE` 次写操作。

---

**DESXADDRINC = 0 (特殊回绕案例)** 此设置表示目的地址不递增（通常用于目标为 **FIFO** 的场景），因此不会发生实际的地址回绕。

- **continue**：源数据耗尽时停止。执行 `SRCXSIZE` 次数的读写。
- **wrap**：由于目的地址不递增，源数据会根据 `SRCXSIZE` 和 `DESXSIZE` 的比例多次拷贝到目的 FIFO。源数据被重复读取，数据在目的 FIFO 中循环。
  - _示例：若 `SRCXSIZE` 为 3，`DESXSIZE` 为 8，目的 FIFO 数据如下：_
    1. `des_data[0] = src_data[0]`
    2. `des_data[1] = src_data[1]`
    3. `des_data[2] = src_data[2]`
    4. `des_data[3] = src_data[0]`
    5. `des_data[4] = src_data[1]`
    6. `des_data[5] = src_data[2]`
    7. `des_data[6] = src_data[0]`
    8. `des_data[7] = src_data[1]`
- **fill**：传输结束时，将填充值拷贝到 FIFO。

### 5.2.3 带增量的 1D 传输

**带增量的 1D 传输**

- 支持对源地址和目的地址设置增量功能
- 支持离散聚合
- 增量设置为零可，实现类外设（peripheral-like）访问
- 增量寄存器为 16 位补码，可为负数

  ![image.png|600](https://pic.lllincx.cn/20260119151912875.png)
  ![image.png|600](https://pic.lllincx.cn/20260119151919318.png)

## 5.3 DMAC 操作扩展命令

本节包含对 DMA-350 操作扩展命令的概述。

### 5.3.1 2D 传输类型

2D 传输用于将图像相关数据按相同的 X 和 Y 方向格式从一个位置拷贝到另一个位置。2D 操作增加了额外的 `YSIZE` 寄存器，用于定义拷贝中包含的行数（每行宽度为 `XSIZE`）。

- **1D 兼容性**：在启用 2D 模式时，若将 `YSIZE` 设置为 1，仍可执行 1D 传输。
- **传输停止**：`YSIZE` 为 0 表示不进行任何传输。
- **重载逻辑**：当 `YSIZE` 大于 1 时，每行结束时 `XSIZE` 会重新加载，并从 1 跳回初始值。当寄存器从 1 过渡到 0 时，意味着命令结束，此过程在 `XSIZE` 和 `YSIZE` 寄存器上同步发生。
- **步幅**：`YADDRSTRIDE` 寄存器定义了每行起始地址之间的地址差。可为负数。

#### 表 5-2：2D 操作的可配置参数

| **参数名称**           | **寄存器映射条目**                 | **描述**                                                                                                                          |
| ---------------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- |
| **2D 启用**            | `CH(x)_CTRL.YTYPE`                 | 该配置寄存器用于启用或禁用 2D 操作，并确定其类型。                                                                                |
| **源地址步幅寄存器**   | `CH(x)_YADDRSTRIDE.SRCYADDRSTRIDE` | 源端的 Y 方向地址步幅。该寄存器通过在当前行起始地址的基础上增加增量来计算下一行的起始地址。                                       |
| **目的地址步幅寄存器** | `CH(x)_YADDRSTRIDE.DESYADDRSTRIDE` | 目的端的 Y 方向地址步幅。该寄存器通过在当前行起始地址的基础上增加增量来计算下一行的起始地址。                                     |
| **源 Y 长度**          | `CH(x)_YSIZE.SRCYSIZE`             | 源端待传输的数据行数。                                                                                                            |
| **目的 Y 长度**        | `CH(x)_YSIZE.DESYSIZE`             | 目的端待写入的数据行数。                                                                                                          |
| **1D 回绕类型**        | `CH(x)_CTRL.XTYPE`                 | 该配置寄存器决定在源和目的 X 长度不等时如何处理 1D 操作。在 2D 操作中，该寄存器的重要性增加，因为某些 1D 回绕操作仅影响 2D 操作。 |

在以下示例中，源端和目的端的大小相等。如果设置不同，可能会发生各种回绕（Wrap）情况，这些情况在启用 WRAP 选项时受支持。在执行 2D 传输时，利用 `XADDRINC` 还可以对拷贝的图像进行微小的变换处理。
![image.png|600](https://pic.lllincx.cn/20260119155954327.png)

**带 X 增量的 2D 传输**

- 在目的地将带有间隙（Gapped）的数据拷贝到指向同一地址的 FIFO
- `DESYADDRSTRIDE` 为负值

![image.png|600](https://pic.lllincx.cn/20260119161243388.png)

**信号处理**
如果 `abs(YADDRSTRIDE)` 的值小于 `abs(XSIZE * XADDRINC)`（考虑负值情况），可能会出现特殊的边缘情况。在这些场景下，相同或轻微偏移的数据会被多次读取，或者同一个目的区域会被重复覆盖。这在信号处理（例如 FFT 或 DCT）中非常有用，因为时域中的多个样本需要被组合并用于频域处理。

**图像编辑**
利用负增量还可以实现特殊的 2D 图像拷贝功能，如镜像（Mirroring）、旋转（Rotating）或转置（Transposing）图像。通过将 `XADDRINC` 设置为大于 `YADDRSTRIDE`，并选择任意位置作为目的地址起始点，可以改变 X 和 Y 的方向。

![image.png|600](https://pic.lllincx.cn/20260119161420604.png)

### 5.3.2 2D 模式下的 WRAP

WRAP 操作通过允许目的端具有不同的尺寸和排列方式，扩展了正常的 2D 拷贝。源端的 `SRCXSIZE` 和 `SRCYSIZE` 参数可以映射到目的端的 `DESXSIZE / DESYSIZE`，两者的大小可以相同也可以不同。这种参数映射会导致目的端空间变小或变大，从而需要不同的回绕（Wrap）类型。这允许将源数据重新塑形（Reshape）到目的端，并支持使用预定义的填充值填充边界。

在使用 2D 回绕时，`XTYPE` 设置也用于处理每一行的回绕类型。它还支持将数据流从源端的一行连续流动到目的端的不同行中。

下图显示了一个 9x8 的源数据块，每个数据项都有不同的颜色。这将在后续示例中用于展示这些数据项最终落在目的地的位置。黑色矩形表示源端的原始帧大小，黄色虚线矩形显示源数据块的完整内容。

`YTYPE` 的设置与 `XTYPE` 非常相似，但它们作用于传输的 Y 方向：

**Y WRAP TYPE**
- **disable**：不执行 2D 传输，忽略 YSIZE 和 YADDRSTRIDE 的值。
- **continue**：禁用回绕。读取 SRCYSIZE 行数据，并由 $min(SRCYSIZE, DESYSIZE)$ 限制传输期间写入的行数。
- **wrap**：启用回绕，源数据行会被多次拷贝到目的区域。
- **fill**：启用填充，目的端的剩余行将使用填充值填充。

#### 5.3.2.1 2D WRAP 情况列表

当 `YTYPE` 未禁用时，受 `XSIZE` 和 `YSIZE` 设置的影响，并不总会产生实际的 2D 传输。下表列出了这些边界情况：

**表 5-3：2D 边界情况**

| **序号** | **SRCXSIZE** | **SRCYSIZE** | **DESXSIZE** | **DESYSIZE** | **情况类型** | **备注**  |
| ------ | ------------ | ------------ | ------------ | ------------ | -------- | ------- |
| 1      | 0            | 0            | 0            | 0            | 1        | 无传输     |
| 2      | 0            | 0            | 0            | >0           | 1        | 无传输     |
| 3      | 0            | 0            | >0           | 0            | 1        | 无传输     |
| 4      | 0            | 0            | >0           | >0           | 2        | 仅写操作    |
| 5      | 0            | >0           | 0            | 0            | 1        | 无传输     |
| 6      | 0            | >0           | 0            | >0           | 1        | 无传输     |
| 7      | 0            | >0           | >0           | 0            | 1        | 无传输     |
| 8      | 0            | >0           | >0           | >0           | 2        | 仅写操作    |
| 9      | >0           | 0            | 0            | 0            | 1        | 无传输     |
| 10     | >0           | 0            | 0            | >0           | 1        | 无传输     |
| 11     | >0           | 0            | >0           | 0            | 1        | 无传输     |
| 12     | >0           | 0            | >0           | >0           | 2        | 仅写操作    |
| 13     | >0           | 1            | >0           | 1            | 4        | 1D 到 1D |
| 14     | >0           | 1            | >0           | >1           | 5        | 1D 到 2D |
| 15     | >0           | >0           | 0            | 0            | 3        | 仅读操作    |
| 16     | >0           | >0           | 0            | >0           | 3        | 仅读操作    |
| 17     | >0           | >0           | >0           | 0            | 3        | 仅读操作    |
| 18     | >0           | >1           | >0           | 1            | 5        | 2D 到 1D |
| 19     | >0           | >1           | >0           | >1           | 5        | 2D 到 2D |

---

表中列出的具体情况说明如下：

1. **无传输**：源端或目的端的行宽或高度为 0，因此不发起总线传输。
2. **仅写操作**：源区域因宽高为 0 无数据发送，但目的区域定义为一行或多行。
3. **仅读操作**：源端定义为单行或多行，但目的区域没有宽度或高度。
4. **1D 到 1D**：源端和目的端均为单行，结果为简单的 1D 到 1D 拷贝，忽略`YTYPE`
5. **维度转换拷贝**：源端或目的端中至少有一个具有 2D 维度，导致 1D 到 2D、2D 到 1D 或 2D 到 2D 的拷贝。

   - 此时 `XTYPE` 和 `YTYPE` 的设置均有效。

#### 5.3.2.2 2D 回绕情况

2D 回绕的具体情况如下：

SRCXSIZE == DESXSIZE

当两行的长度相等时，情况较为简单，此时 XTYPE 的设置无关紧要。

SRCYSIZE == DESYSIZE

不发生回绕，源区域与目的区域完全相同。

SRCYSIZE > DESYSIZE

目的端小于源端。无论回绕类型如何，拷贝都会在目的端填满时停止。这确保了目的端不会发生数据覆盖。源数据仍会被读取，因为可能需要通过流输出接口发送，或者直接丢弃。

SRCYSIZE < DESYSIZE

目的端大于源端，可以使用不同的回绕选项：

- **YTYPE: continue**：当达到 `SRCYSIZE` 时停止拷贝。
- **YTYPE: wrap**：地址计数器发生回绕，开始将源数据的开头部分拷贝到目的内存的剩余位置。
- **YTYPE: fill**：使用填充数据填充剩余的 Y 行。

![image.png|600](https://pic.lllincx.cn/20260119165955567.png)

SRCXSIZE > DESXSIZE

此类场景涵盖源行宽大于目的行宽的情况。

- SRCYSIZE >= DESYSIZE：
  拷贝到较小的区域，目的端可能发生行回绕。由于 YSIZE 较小或相等，不会发生覆盖，因此 YTYPE 无关紧要。XTYPE 会影响数据拷贝到目的地的具体方式。
  - **XTYPE: wrap, fill**：由于目的端小于源端，拷贝在目的行填满时停止。
  - **XTYPE: continue**：源行中的剩余数据会连续写入目的端的下一行。超出目的端范围的最后几拍数据将不被拷贝。
  - **YTYPE: continue, wrap, fill**：目的高度小于源高度，拷贝在目的区域填满时停止。

![image.png|600](https://pic.lllincx.cn/20260119171227429.png)

- SRCYSIZE < DESYSIZE：
  拷贝到形状不同的区域（目的端 X 更窄，但 Y 更高）。这种数据重塑（Reshaping）可以通过选择 1D 和 2D 回绕类型来处理。

在此类场景中，由于 X 行较窄，`XTYPE` 为 `continue`、`wrap` 和 `fill` 时效果不同。`continue` 选项会导致用源行中剩余的数据填充下一行。

有一种特殊情况，即源和目的区域大小相同但形状不同。例如图中的 $SX=9, SY=8, DX=8, DY=9$ 情况，当公式中的 $n=0$ 时，由于源端的完整数据恰好填满目的端，`YTYPE` 失去意义，不会发生回绕或填充。如果 $n > 0$，意味着在源端数据全部用完后，目的端仍留有完整的空行，此时可以执行回绕或填充。

另一个 `continue` 示例展示了目的端最后一行仅部分被源数据填充的情况。这些场景也可以触发回绕和填充，但它们会从目的行的中间位置开始。

SRCXSIZE < DESXSIZE

此类场景涵盖目的行宽大于源行宽的情况。

- SRCYSIZE >= DESYSIZE：
  源矩形可能仍高于目的矩形。如果源数据无法装入目的端，则会被截断；如果矩形大小匹配，则进行重塑；如果目的端大于源端，甚至可能发生回绕。由于目的行比源行宽，XTYPE 的设置会产生不同的单行模式。

当 `XTYPE` 设置为 `continue`、`wrap` 或 `fill` 时，`YTYPE` 的相应值作用相同。这是因为目的行数少于或等于源行数，意味着目的行不会被覆盖。

在这种意义上，`XTYPE` 的 `continue` 情况比较特殊，因为多个源行会被合并以连续填满单个目的行。这实现了目的端的数据重塑，而 `YTYPE` 则决定了目的端剩余空间的填充方式。这种情况还包括特殊子类：即目的行被完全填满（此时可在整行级别进行回绕或填充），或者目的行仅由源端的最后几拍数据部分填充（此时目的地的剩余部分可包含回绕的源数据开头，或填充预定义模式）。

- SRCYSIZE < DESYSIZE：
  此场景中目的矩形在所有方向上都更大，因此 1D 和 2D 方向均可发生回绕。与前一种情况的不同之处在于，当 XTYPE 设置为 continue、wrap 或 fill 时，YTYPE 同样起作用。

`XTYPE` 的 `continue` 设置可以根据 `YTYPE` 扩展或填充目的区域的 Y 方向。`YTYPE` 的 `continue` 设置可以扩展或填充目的区域的 X 方向。

通过选择 `continue` 选项，这也可用于 **1D 到 2D 拷贝**，使源数据以连续方式拷贝到目的地。当两个方向都设置为 `wrap` 时，可以将相同数据像瓷砖一样平铺（Tiling）到更大的区域。两个方向都设置为 `fill` 则可以在图像的两侧创建边框。若要创建完整的四周边界，需要通过链接多个命令来实现。使用负增量可以在图像的上方和右侧创建边界。

### 5.3.3 模板化传输（Templated transfers）

模板化传输功能允许 1D 传输根据预定义的模式选择性地拷贝数据。这些模式通过模板寄存器定义，描述了要传输地址的重复位掩码（Bit-mask）。

位掩码定义在模板寄存器 `SRCTMPLT` / `DESTMPLT` 中。源端和目的端拥有独立的模板寄存器以及用于定义模板长度的模板尺寸字段。源端和目的端可以独立配置。

- **起始位限制**：模板寄存器的最低位固定为 **1**。这意味着传输开始时不能有初始间隙，在 `SRCADDR` / `DESADDR` 定义的起始地址处始终会发生数据传输。如果确实需要初始间隙，则必须偏移地址，使首次实际传输点位于起始地址处。
- 尺寸定义：实际模板尺寸计算公式为：
  $$\text{Actual Template Size} = \text{TMPLTSIZE} + 1$$
  默认设置（全 0）表示禁用模板化功能。通过将模板尺寸设置为大于 0（即 SRCTMPLTSIZE > 0 或 DESTMPLTSIZE > 0）来启用该功能。模板寄存器中超出定义模板尺寸的高位位掩码将被忽略。

#### 地址计算

模板化传输功能始终使用**单次传输（Single Transfers）**来搬运数据，它不会尝试将连续的传输合并为突发传输（Bursts）。在每个周期内，硬件都会为该传输计算一个新地址。

#### 带流接口的模板化传输

流接口（AXI4-Stream）不感知模板类型，因为它始终接收**打包数据（Packed Data）**。模板模式仅在源端和目的端的 AXI 地址寻址阶段处理。

## 5.4 DMAC 操作触发器 (Triggers)

触发输入和输出可以在无需软件干预的情况下同步系统内的活动。启用后，DMAC 可以基于通道配置触发输入和输出。输入触发支持多种模式以满足不同需求，而输出触发通常用于标记完整 DMAC 操作的最后一步。DMA-350 的**触发矩阵 (Trigger Matrix)** 负责处理外部触发端口与 DMA 通道之间的连接，使 DMA 通道能够选择使用哪些触发端口，或连接到其他 DMA 通道。

### 5.4.1 触发输入 (Trigger Inputs)

触发输入端口利用触发信号使外设能够与 DMAC 通信，并在无需软件干预的情况下安排 DMAC 操作的顺序。触发器为 DMAC 操作内的传输提供**流控制 (Flow Control)**，也可用于启动整个 DMAC 操作。触发输入的具体使用模式可通过配置寄存器进行选择。

外设与 DMA-350 之间采用 **4 相位握手总线 (4-phase handshake bus)**。额外的限定信号（Qualifier signals）在两个方向上扩展了 `req` (请求) 和 `ack` (应答) 信号对。

- **请求端**：外设通过 `req` 信号告知 DMAC 有数据待传输。
- **限定信号 (`reqtype`)**：用于指示传输类型（单次或块传输）以及是否为最后一批数据。

#### 表 5-4：触发请求类型 (`reqtype`)

| **值**  | **名称**        | **描述**                                                                                      |
| ------- | --------------- | --------------------------------------------------------------------------------------------- |
| `2'b00` | **SINGLE**      | 外设请求单次传输（大小由 `TRANSIZE` 定义）。                                                  |
| `2'b10` | **BLOCK**       | 外设请求一个较大的数据块。块大小在 DMAC 和外设中预先定义，可包含多次突发传输。                |
| `2'b01` | **LAST SINGLE** | 当外设作为流控制器且 DMAC 不知晓总数据量时，外设通过请求最后一个单次传输来结束任务。          |
| `2'b11` | **LAST BLOCK**  | 与 LAST SINGLE 类似，但最后的传输请求是一个定义的块大小。用于总传输大小能被块大小整除的情况。 |

DMA-350 通过 `ack` 信号告知外设已收到请求。限定信号总线 `acktype` 提供额外信息，说明请求是否被接受，或 DMAC 传输是否在当前事务后结束。

#### 表 5-5：触发应答类型 (`acktype`)

| **值**  | **名称**      | **描述**                                                                                                                        |
| ------- | ------------- | ------------------------------------------------------------------------------------------------------------------------------- |
| `2'b00` | **OKAY**      | DMAC 接受了请求类型。表示 DMAC 将执行传输，但不一定在应答的同时执行。DMAC 可能会在执行前接受多个请求。                          |
| `2'b10` | **LAST OKAY** | DMAC 接受了请求，并告知外设这是操作的最后一次传输。用于同步外设请求的 LAST 信号，或在 DMAC 作为流控制器时告知外设重置计数器。   |
| `2'b01` | **DENY**      | DMAC 目前无法接受此请求。常用于 DMAC 预期进行块传输优化，但外设却请求 SINGLE 传输时，通过拒绝 SINGLE 请求使握手返回 IDLE 状态。 |
| `2'b11` | **RESERVED**  | 保留。                                                                                                                          |

启用后，一个通道拥有两个触发输入端口：

1. **源端触发 (Source Triggering)**：控制读操作。
2. **目的端触发 (Destination Triggering)**：控制写操作。

触发输入的数量是可配置的，可以与通道数量不同。软件通过**触发矩阵**为通道选择触发源。如果软件想禁用触发，可在控制寄存器中将模式设为 `disabled`，此时 DMA 通道在使能位（Enable bit）置位后立即开始执行。

#### 状态处理与调试

- **悬起请求 (Pending req)**：如果请求到达时没有通道连接，或通道已完成采样但尚未交还控制权，`req` 会保持悬起。当新通道连接到该端口时，会立即收到该请求。
- **暂停与停止 (Pause & Stop)**：通道暂停时，触发服务也随之暂停。通道停止时，触发矩阵会收回控制权。对于输出触发，矩阵会自动响应内部 ack。
- **自动清除与软件触发**：软件可以发起触发请求的“自动清除”（通过发送 `deny`），也可以通过寄存器模拟硬件触发进行调试。

---

### 5.4.1.1 触发输入命令模式 (Trigger input command mode)

触发输入可用于启动完整的 DMA 命令。当源端或目的端被设置为此模式时，即使 DMA 通道的使能位（enable bit）已置位，DMA 命令也会在开始任何内存操作前等待触发握手。DMAC 会等待**源端和目的端的请求同时有效（asserted）**后才进行应答，以此指示命令正式启动。

如上图所示，目的端触发请求先到达，但直到 DMAC 检测到源端触发请求后才会发出应答。此时，源端和目的端的触发均被应答，DMAC 传输开始。触发握手返回 IDLE 的时间点取决于请求信号的驱动方，但这不会干扰数据传输的执行。然而，**只有当两个触发应答信号（ack）都撤销（deasserted）后，命令才算真正结束。**

- **等待状态**：在握手完成（ack 变为 HIGH）之前，DMAC 处于活跃等待状态（Active waiting state），不会向总线接口发送传输请求。
- **执行启动**：当所有基于命令的触发输入握手完成（即 `req` 和 `ack` 均为 HIGH）时，命令开始执行并退出等待状态。在整个 DMAC 操作持续期间，DMAC 不再接受新的触发请求。
- **信号类型**：对于命令模式触发，`reqtype[1:0]` 可以是 SINGLE / BLOCK / LAST SINGLE / LAST BLOCK。
- **应答类型**：`acktype[1:0]` 的 OKAY 和 LAST OKAY 均为有效值，DMA-350 会返回 OKAY。在此模式下不使用 DENY。

硬件/软件触发交互

源端和目的端均可设置为硬件或软件控制的命令模式。

- **软件触发覆盖**：可以通过编写软件可编程寄存器产生内部触发请求事件来覆盖输入触发。无论哪种类型的触发到达，DMA 通道都会启动。
- **冲突处理**：如果命令已经在运行，此时到达的软件触发无效。如果软件已请求触发，此时到达的硬件触发将保持悬起（pending）。如果两者同时到达，硬件触发将被处理。

握手撤销逻辑

当命令触发的请求撤销时，DMAC 会尽快撤销应答，以便触发发送方继续其操作。

以下是 DMAC 在使用命令触发时的应答撤销时序说明：
![image.png|600](https://pic.lllincx.cn/20260121102840147.png)

- **t0**：触发接口处于 IDLE（空闲）。
- **t1**：外设请求任意类型的触发以启动命令。
- **t2**：如果 DMA 通道正在等待触发并准备好执行操作，DMAC 接受请求（ack 拉高）。
- **t3**：外设在收到 DMAC 的 OKAY 响应后撤销 `req` 信号。此时 DMAC 仍在执行请求的操作。
- **t4**：DMAC 检测到 `req` 已撤销，随后撤销 `ack`，触发接口返回 IDLE。此时命令仍在运行。
- **t5**：命令执行完毕，但这不会反映在触发输入接口上。可以使用输出触发（Trigger out）信号来指示命令的结束。

---

#### 5.4.1.2 触发输入流控制模式 (Trigger input flow control mode)

触发输入还可用于流控制目的，即每次触发仅使能大型命令中的一小部分传输。在此模式下，软件必须设置**触发尺寸（trigger size）**，它规定了每次触发事件所允许访问的“传输位宽块”的数量。源端触发输入用于控制读流，而目的端触发输入则控制 DMA 操作的写流。

![image.png|600](https://pic.lllincx.cn/20260120173606604.png)

- **读写同步逻辑**：读传输只有在接收到目的端命令触发和源端触发后才能开始。目的端的写操作只有在从源端接收到足够的数据后才能开始。
- **读操作停滞**：当源端触发设置为流控制模式时，DMA 通道的读操作会停滞，直到接收到第一个触发请求。

![image.png|600](https://pic.lllincx.cn/20260120173612727.png)

图中显示，尽管目的端触发请求先到达，但命令仍必须等待源端触发到达。在接收到源端命令触发后，读传输立即开始。只有在接收到目的端触发且有足够数据待发送时，写操作才会开始。DMAC 会在其内部 FIFO 中预加载数据，以便在接收到下一个目的端触发时，写操作能尽快发生。

当设置了目的端触发时，DMA 通道的写操作将停滞，直到接收到第一个触发请求。在目的端触发握手完成之前，读操作可以先行启动并填满 FIFO。

一旦接收到触发输入请求，命令执行即可开始，且 DMA 通道退出等待状态。DMAC 仅访问由块大小（block size）寄存器指定的传输数量作为最大值。直到完成块大小数量的传输（最后一个块允许较小）并收到最后一次传输的响应（response）后，DMAC 才会拉高触发应答（acknowledge）。

DMA 通道在断言（assert）应答之前，会等待所有响应事务到达。握手必须返回空闲（idle）状态，状态机才能返回“等待触发”或“完成”状态。由于地址生成逻辑会停滞直到收到最后的响应，这增加了触发之间的延迟。然而，这也能避免外设侧并行触发应答与 AXI 传输之间的时序冲突。

可以设置 DMA 通道，使源端和目的端均允许 DMAC 流控操作。在此模式下，DMA 通道会统计传输数量，并在达到要求数量时结束通道操作。当仍有待传输块时，DMA 通道向外设发送 **OKAY ACK**；当到达最后一个传输块时，发送 **LAST OKAY ack**。

**块触发（Block Triggers）下的应答撤销时序（t0-t4）：**

![image.png|600](https://pic.lllincx.cn/20260121102941727.png)

- **t0**：触发接口处于 IDLE。
- **t1**：外设请求 BLOCK 或 SINGLE 触发类型。
- **t2**：DMAC 尽快开始执行请求；到 t2 时，该操作请求的所有传输均已完成。
- **t3**：外设在收到 DMAC 的 OKAY 响应后撤销 `req` 信号。
- **t4**：DMAC 完成请求服务，并在准备好接受新请求时撤销 `ack` 信号。

### 5.4.2 触发输出 (Trigger outputs)

触发输出用于在 DONE 中断断言（asserted）之前定义命令执行的结束。它们可用于同步系统中硬件单元之间的活动。

在等待触发输出应答（acknowledge）时，通道操作将停滞（stalled），直到接收到应答且该通道的触发输出接口返回空闲（IDLE）状态。

### 5.4.3 用于源选择的触发矩阵 (Trigger matrix for selectable sources)

DMA-350 为触发输入和输出实现了触发矩阵，每个触发都可以根据寄存器设置分配给特定通道。触发矩阵还可以在一个通道的触发输出端口与另一个通道的触发输入端口之间建立连接，从而利用内部事件启动触发。

触发输入的数量是可配置的，且可以与通道数量不同。软件能够通过触发矩阵为通道选择触发输入。

DMA-350 管理选择过程，仅允许触发器与通道之间的有效连接。硬件会检查通道和触发端口的**安全属性（security attribute）**，并且一个触发端口不能同时被多个通道选择。在某些场景下，外部触发端口虽未被选择，但由于软件干预仍处于处理请求的状态，这些场景也由矩阵覆盖，直到软件干预的副作用清除后，触发端口才变为可选状态。

如果由于以下原因导致触发输入接口不可选，则选择操作会报错：

- 该接口已被另一个通道占用。
- 触发端口未被选择，但有多个通道尝试在同一个周期内选择它。
- 由于安全属性差异（Security attribute differences）而不允许选择。
- 触发输入接口由于正在进行软件发起的清除握手（clear handshake）而未处于 IDLE 状态。
- 使用内部触发时，触发输入端口不能连接到**同一个通道**的触发输出端口。

如果由于以下原因导致触发输出接口不可选，则选择操作会报错：

- 该接口已被另一个通道占用。
- 触发端口未被选择，但有多个通道尝试在同一个周期内选择它。
- 由于通道与触发端口的安全属性差异而不允许选择。
- 触发输出接口由于之前未完成的触发握手而未处于 IDLE 状态（可能是由于 pending 的 `req` 未收到 `ack`，或者握手结束时 `ack` 卡在高温状态）。
- 使用内部触发时，触发输出端口不能连接到**同一个通道**的触发输入端口。

### 5.4.4 内部触发连接 (Internal trigger connection)

DMA-350 通过内部触发连接实现两个通道的同步。一个通道（发送通道）的触发输出端口可以内部连接到另一个通道（接收通道）的触发输入端口。触发输出端口上的 `req` 信号标志着一个命令的结束，并启动接收通道上另一个命令的操作。

**使用内部触发的通道始终处于命令触发模式（command trigger mode），无论配置的触发类型为何。**

发送通道会等待来自接收通道的触发 `ack`。当接收通道配置为命令触发时，`ack` 会在发送通道撤销 `req` 后立即撤销。这意味着当接收通道开始其命令时，发送通道可以继续执行新的命令。

可以形成由两个以上通道通过内部连接触发而构成的链条。这些连接的通道甚至可以组成一个**闭环（closed loop）**。在这种情况下，可以使用软件触发来启动链条中的第一次操作。

当通道数量仅为一个时，无法使用内部触发。如果配置了内部硬件触发模式，它将被视为外部硬件触发模式。

### 5.4.5 软件触发 (Software Triggers)

软件触发接口允许软件直接与 DMAC 的触发逻辑进行交互。它通常用于软件与 DMAC 操作的同步，或者在开发阶段作为硬件触发事件的替代方案。

#### 5.4.5.1 软件触发接口

软件触发接口由以下 DMA 通道寄存器位域组成：

| **寄存器**                | **位域名称**                         | **说明**                 |
| ------------------------- | ------------------------------------ | ------------------------ |
| **`CH(x)_CMD`** (控制)    | `SRCSWTRIGINREQ` / `SRCSWTRIGINTYPE` | 源端软件触发请求及类型   |
|                           | `DESSWTRIGINREQ` / `DESSWTRIGINTYPE` | 目的端软件触发请求及类型 |
|                           | `SWTRIGOUTACK`                       | 软件触发输出应答         |
| **`CH(x)_STATUS`** (状态) | `STAT_SRCTRIGINWAIT`                 | 等待源端触发状态         |
|                           | `STAT_DESTRIGINWAIT`                 | 等待目的端触发状态       |
|                           | `STAT_TRIGOUTACKWAIT`                | 等待触发输出应答状态     |
| **`CH(x)_STATUS`** (中断) | `INTR_SRCTRIGINWAIT`                 | 源端触发等待中断标志     |
|                           | `INTR_DESTRIGINWAIT`                 | 目的端触发等待中断标志   |
|                           | `INTR_TRIGOUTACKWAIT`                | 触发输出应答等待中断标志 |
| **`CH(x)_INTREN`** (使能) | `INTREN_SRCTRIGINWAIT`               | 使能源端触发等待中断     |
|                           | `INTREN_DESTRIGINWAIT`               | 使能目的端触发等待中断   |
|                           | `INTREN_TRIGOUTACKWAIT`              | 使能触发输出应答等待中断 |

---

#### 5.4.5.2 软件触发协议

等待状态 (STATWAIT) 是启动软件触发的前提条件。只有当该位为 1 时，DMA 通道才准备好接受软件触发；如果为 0，则无法发起。

**1. 软件触发输入协议 (Input Protocol):**

- **设置类型**：首先在 `*SWTRIGINTYPE` 位域中设置所需的触发类型（如 SINGLE/BLOCK）。
- **发起请求**：向 `*SWTRIGINREQ` 位写入 **1**。设置类型和发起请求可以在同一次寄存器写操作中完成，也可以分步执行。
- **硬件处理**：请求发起后，硬件会自动清除关联的 `STAT_*TRIGINWAIT` 标志，表示请求已开始处理。此时，为了保证触发事件期间的稳定性，`*SWTRIGINTYPE` 位域会变为**只读 (Read-Only)**。
- **完成清除**：触发请求完成后，硬件会自动清除 `*SWTRIGINREQ` 位，并将 `*SWTRIGINTYPE` 恢复为可读写状态。

**2. 软件触发输出协议 (Output Protocol):**

- 当 `STAT_TRIGOUTACKWAIT` 为 **1** 时，表示触发输出请求处于活跃状态。
- **软件应答**：软件通过向 `SWTRIGOUTACK` 位写入 **1** 来发送应答信号。
- 应答被硬件接受后，`STAT_TRIGOUTACKWAIT` 状态位会被自动清除。

---

#### 5.4.5.3 软件触发中断

- **生成条件**：当对应的 `STAT_*` 状态位置位，且 `INTREN_*` 中断使能位为 1 时，会触发相应的 `INTR_*` 中断标志。
- **自动清除**：当硬件逻辑清除 `STAT_*` 状态位时，对应的中断标志位也会**自动清除**。

## 5.5 AXI4 Stream 操作

为了提供灵活的数据处理能力，DMA-350 允许在数据流中加入外部引擎（External Engine）。

典型的流水线为：

1. **AXI5 管理器接口**从内存读取数据。
2. 数据通过 **AXI4-Stream 接口**发送给外部引擎（例如滤波器单元）。
3. 外部引擎处理后，将校正后的数据送回 DMAC。
4. **DMAC** 通过 AXI5 接口将修改后的数据写回内存。

---

### 5.5.1 Stream In 接口的包边界（从外部引擎回到 DMAC）

Stream In 接口期望整个 DMA 命令对应一个**单一数据包**。

- **TLAST 的含义**：当从外部引擎接收到 `tlast` 信号时，意味着引擎没有更多数据需要发送，当前 DMA 命令结束。
- **提前收到 TLAST（压缩场景）**：
  - 如果收到 `tlast` 时，`DESXSIZE` 或 `DESYSIZE` 仍大于 0，则命令提前结束。
  - **continue 选项**：发送完带 `tlast` 的数据后，不再生成后续的目标端传输。这适用于“压缩”场景（实际生成的数据量小于设定的目标区域上限）。
  - **fill 设置**：对于 1D 传输，会使用 `FILLVALUE` 填充剩余区域直到 `DESXSIZE` 减为 0。对于 2D 传输，填充仅对 `YTYPE` 有效（因为单行宽度未知，设置 `XTYPE` 填充会导致错误）。
- **对齐要求**：
  - **最后一次传输（Last Beat）的大小必须与 `TRANSIZE` 对齐**。
  - 如果不满足对齐，AXI5 写侧无法处理该数据，将产生 **Stream In Error** 并停止 DMAC 任务。因此，`TRANSIZE` 的选择必须契合外部流引擎的算法特性。
- **编程错误（缺失 TLAST）**：
  - 如果 `DESXSIZE` 和 `DESYSIZE` 已减至 0 但未收到 `tlast`，DMAC 会停止向总线发送数据并上报错误。
  - 此时通道会继续接收并**丢弃**输入流数据，直到检测到 `tlast` 或接口复位。

#### Stream In 冲刷（Flush）行为

当 DMA 命令必须在收到 `tlast` 之前结束操作时，会断言 **FLUSH** 输出信号。

- 当 FLUSH 为高时，DMAC 会丢弃所有通过 `TVALID/TREADY` 握手接收的数据。
- FLUSH 会一直保持有效，直到在 Stream In 接口上接收到一个带有 `tlast` 的握手。
- 在 FLUSH 过程完成前，DMA 命令无法彻底结束。

---

### 5.5.2 Stream Out 接口的包边界（从 DMAC 发往外部引擎）

Stream Out 接口为整个 DMA 命令向外部引擎发送一个单一的 AXI4-Stream 数据包。

- 该包可包含多个传输拍（Beats）。
- 由于接口不支持 `TID`（线程 ID），所有传输均位于同一个包内。

---

### 5.5.3 流接口与其他模式的协同工作

流接口可以与 DMAC 的其他特性并行启用，但存在一些限制。

#### 5.5.3.1 与 1D 和 2D 类型的协同

当使用流接口时，`XTYPE` 和 `YTYPE` 的设置受到约束，因为流接口在某些情况下无法使用回绕（Wrap）和填充（Fill）模式。

| **模式**        | **允许的配置** | **原因**                                                       |
| --------------- | -------------- | -------------------------------------------------------------- |
| **Wrap (回绕)** | **禁用**       | 流数据是单向连续的，硬件无法在流接口上重现内存的回绕寻址逻辑。 |
| **Fill (填充)** | **受限**       | 仅在满足特定对齐和边界条件时允许，否则会导致流协议违背。       |

### 5.5.3.1 与 1D 和 2D 类型的协同工作

在使用流（Stream）接口时，`XTYPE` 和 `YTYPE` 的设置会受到限制。这是因为流接口无法处理数据“回头重读”（回绕模式），且在某些情况下无法确定填充边界。

#### 表 5-6：1D 和 2D 类型的流接口配置限制

| **模式** | **XTYPE**    | **YTYPE**    | **是否允许启用流** | **说明**                                                                                     |
| -------- | ------------ | ------------ | ------------------ | -------------------------------------------------------------------------------------------- |
| **OFF**  | 禁用         | 禁用         | N/A                | 无论是否启用流接口，均不发生数据传输。                                                       |
| **1D**   | **Continue** | 禁用         | **是**             | 简单的 1D 传输支持所有流类型。仅使用流输出时忽略 `DESXSIZE`；仅使用流输入时忽略 `SRCXSIZE`。 |
| **1D**   | **Fill**     | 禁用         | **是**             | 收到 `tlast` 后，若目的行仍有空间，剩余区域将使用 `FILLVAL` 填充。                           |
| **1D**   | **Wrap**     | 禁用         | **否**             | **配置错误**。流输入数据无法再次获取，因此不支持回绕。                                       |
| **2D**   | **Continue** | **Continue** | **是**             | 支持简单的 2D 传输。流输入发送早期 `tlast` 时，目的端传输可在行中途停止。                    |
| **2D**   | **Continue** | **Fill**     | **是**             | 收到 `tlast` 后，若目的区域仍有空间（行数不足），剩余区域将使用 `FILLVAL` 填充。             |
| **2D**   | **Continue** | **Wrap**     | **否**             | **配置错误**。流输入数据无法重读。                                                           |
| **2D**   | **Wrap**     | 任何         | **否**             | **配置错误**。原因同上。                                                                     |
| **2D**   | **Fill**     | 任何         | **否**             | **配置错误**。流输入数据不包含“行结束”指示，DMAC 无法判断何时开始填充行的剩余部分。          |

---

### 5.5.3.2 与触发接口（Trigger Interface）的协同工作

流接口的使用对**触发输入接口**有一定限制，因为将基于“块”的传输（Block-based transfers）转换为流输出传输时，可能会导致行为异常。

核心冲突点：

流输出传输在 AXI4-Stream 术语中被视为一个完整的包（Packet）。包中间不允许出现间隙（Strobes）。

- 如果触发设置（单次或块）未与流接口的数据位宽对齐，接口将会**停滞（Stall）**。
- 如果 DMAC 获取了剩余数据并将其存储在内部 FIFO 中，但在下一个块被触发之前，外部流引擎将无法获得完整的数据进行处理。

#### 表 5-7：触发器的流接口配置限制

| **模式**             | **SRC/DESTRIGINTYPE** | **是否允许启用流** | **说明**                                                   |
| -------------------- | --------------------- | ------------------ | ---------------------------------------------------------- |
| **软件控制命令触发** | `000`                 | **是**             | 软件可以启动任何方向使用流接口的完整命令。                 |
| **硬件控制命令触发** | `100`                 | **是**             | 硬件可以启动任何方向使用流接口的完整命令。                 |
| **任何流控触发**     | `001, 101, 110`       | **否**             | 流接口不支持在非位宽对齐的触发块大小设置下停滞或插入空拍。 |

> **替代方案**：如果外设需要基于“包”的触发，应将 `SRCXSIZE` 或 `DESXSIZE` 设置为单个包的大小，并在下一个包到来时**重载命令**。这可以替代“大 XSIZE + 块触发”的方案，其中 `TRIGBLOCKSIZE` 代表一个独立的包。

**其他说明：**

- **触发输出（Trigger out）**：在使用流接口时，触发输出信号的使用不受任何限制。
- **触发环路（Trigger loops）**：仅可用于启动接收端的完整命令，因为流接口不支持流控（Flow Control）模式。

### 5.5.3.1 与 1D 和 2D 类型的协同工作

在使用流（Stream）接口时，`XTYPE` 和 `YTYPE` 的设置会受到限制。这是因为流接口无法处理数据“回头重读”（回绕模式），且在某些情况下无法确定填充边界。

#### 表 5-6：1D 和 2D 类型的流接口配置限制

| **模式** | **XTYPE**    | **YTYPE**    | **是否允许启用流** | **说明**                                                                                     |
| -------- | ------------ | ------------ | ------------------ | -------------------------------------------------------------------------------------------- |
| **OFF**  | 禁用         | 禁用         | N/A                | 无论是否启用流接口，均不发生数据传输。                                                       |
| **1D**   | **Continue** | 禁用         | **是**             | 简单的 1D 传输支持所有流类型。仅使用流输出时忽略 `DESXSIZE`；仅使用流输入时忽略 `SRCXSIZE`。 |
| **1D**   | **Fill**     | 禁用         | **是**             | 收到 `tlast` 后，若目的行仍有空间，剩余区域将使用 `FILLVAL` 填充。                           |
| **1D**   | **Wrap**     | 禁用         | **否**             | **配置错误**。流输入数据无法再次获取，因此不支持回绕。                                       |
| **2D**   | **Continue** | **Continue** | **是**             | 支持简单的 2D 传输。流输入发送早期 `tlast` 时，目的端传输可在行中途停止。                    |
| **2D**   | **Continue** | **Fill**     | **是**             | 收到 `tlast` 后，若目的区域仍有空间（行数不足），剩余区域将使用 `FILLVAL` 填充。             |
| **2D**   | **Continue** | **Wrap**     | **否**             | **配置错误**。流输入数据无法重读。                                                           |
| **2D**   | **Wrap**     | 任何         | **否**             | **配置错误**。原因同上。                                                                     |
| **2D**   | **Fill**     | 任何         | **否**             | **配置错误**。流输入数据不包含“行结束”指示，DMAC 无法判断何时开始填充行的剩余部分。          |

---

### 5.5.3.2 与触发接口（Trigger Interface）的协同工作

流接口的使用对**触发输入接口**有一定限制，因为将基于“块”的传输（Block-based transfers）转换为流输出传输时，可能会导致行为异常。

核心冲突点：

流输出传输在 AXI4-Stream 术语中被视为一个完整的包（Packet）。包中间不允许出现间隙（Strobes）。

- 如果触发设置（单次或块）未与流接口的数据位宽对齐，接口将会**停滞（Stall）**。
- 如果 DMAC 获取了剩余数据并将其存储在内部 FIFO 中，但在下一个块被触发之前，外部流引擎将无法获得完整的数据进行处理。

#### 表 5-7：触发器的流接口配置限制

| **模式**             | **SRC/DESTRIGINTYPE** | **是否允许启用流** | **说明**                                                   |
| -------------------- | --------------------- | ------------------ | ---------------------------------------------------------- |
| **软件控制命令触发** | `000`                 | **是**             | 软件可以启动任何方向使用流接口的完整命令。                 |
| **硬件控制命令触发** | `100`                 | **是**             | 硬件可以启动任何方向使用流接口的完整命令。                 |
| **任何流控触发**     | `001, 101, 110`       | **否**             | 流接口不支持在非位宽对齐的触发块大小设置下停滞或插入空拍。 |

> **替代方案**：如果外设需要基于“包”的触发，应将 `SRCXSIZE` 或 `DESXSIZE` 设置为单个包的大小，并在下一个包到来时**重载命令**。这可以替代“大 XSIZE + 块触发”的方案，其中 `TRIGBLOCKSIZE` 代表一个独立的包。

**其他说明：**

- **触发输出（Trigger out）**：在使用流接口时，触发输出信号的使用不受任何限制。
- **触发环路（Trigger loops）**：仅可用于启动接收端的完整命令，因为流接口不支持流控（Flow Control）模式。

## 5.6 DMA 通道生命周期

DMA 通道的生命周期包含三个核心状态：**禁用 (Disabled)**、**使能 (Enabled)** 和 **暂停 (Paused)**。

---

### 1. 禁用状态 (Disabled State)

- **初始状态**：复位后，通道默认处于禁用状态。
- **配置**：软件在此状态下对通道寄存器进行初始化。所有可写寄存器此时均受软件控制。
- **启动**：通过向 `CH(x)_CMD.ENABLECMD` 位写入 1，通道进入使能状态。

### 2. 使能状态 (Enabled State)

- **控制权移交**：一旦进入此状态，通道的配置寄存器转由 **硬件 (HW)** 控制。软件仍可读取，但内容由硬件动态更新。
- **动态更新**：以下寄存器会实时反映传输进度：
  - `ADDR / ADDRHI`：指向下一个待访问的内存地址。
  - `XSIZE / XSIZEHI` / `YSIZE`：从起始值减至 0（注意：2D 或回绕操作可能会重载这些计数器）。
- **软件干预**：使能期间，软件仅能通过 `CH(x)_CMD`、`CH(x)_STATUS` 和 `CH(x)_WRKREGPTR` 进行停止、暂停、清除中断或查看内部工作寄存器操作。
- **结束条件**：
  - 命令成功完成。
  - 发生错误事件（如配置错误）。
  - 手动禁用 (`DISABLECMD`) 或手动停止 (`STOPCMD` / 全局停止信号)。

### 3. 暂停状态 (Paused State)

- **触发方式**：软件 `PAUSECMD`、全局暂停信号、完成并暂停 (`DONEPAUSEEN`)、交叉触发接口 (CTI) 或热复位。
- **硬件表现**：
  - **总线事务停止**，触发处理挂起。
  - 通道状态“冻结”，地址和尺寸寄存器反映停滞瞬间的精确状态。
- **调试支持**：软件可以通过设置 `CH(x)_WRKREGPTR` 并读取 `CH(x)_WRKREGVAL` 来检查 **内部工作寄存器 (Work Registers)**。
- **恢复执行**：
  - 软件通过设置 `RESUMECMD` 位撤销暂停。
  - 硬件/全局暂停则通过清除相应的状态位或撤销硬件信号来恢复。

### 5.6.1 命令执行状态 (Command Execution States)

每一个 DMA 命令都包含多个按固定顺序执行的步骤。根据配置的不同，某些步骤可以被跳过。

#### 1. 配置检查状态 (Configuration checking)

验证通道的寄存器配置。如果检测到无效的寄存器值或配置冲突，硬件将置位错误状态位并停止通道运行。

#### 2. 触发分配状态 (Trigger allocation)

如果配置了外部硬件触发或内部触发，在此状态下建立物理触发端口与通道的连接。

- **连接失败**：若无法建立连接（如权限冲突或端口被占用），将指示触发选择错误并停止运行。
- **跳过**：若配置为软件触发或无触发，则忽略此步骤。
- **GPO 更新**：在进入下一状态前，GPO 输出（如果已配置）将被设置为新值。

#### 3. 命令触发状态 (Command trigger)

处理命令模式下的输入触发请求：

- 通道执行保持停滞，直到所有设为命令模式的触发输入都接收到请求。
- 只有当**所有**请求都收到后，硬件才会断言（Assert）触发应答（Ack）。

#### 4. 数据传输状态 (Data transfer)

执行实际的数据搬运。**流控触发（Flow-control trigger）**仅在此状态下进行处理。

#### 5. 触发输出状态 (Trigger output)

作为命令的最后一步，如果配置了输出触发，则断言触发输出请求。操作会停滞，直到收到来自接收方的应答。

#### 6. 完成状态 (Done)

表示命令已成功完成：

- **清理**：释放触发连接，并根据 `DONE_TYPE` 设置 `STAT_DONE` 标志。
- **自动重启/链接**：
  - 若 `CMDRESTARTCNT` 非零或 `CMDRESTARTINFEN` 置位，则自动重启当前命令。
  - 若无自动重启，检查 `LINKADDREN`。若置位，则启用**命令链接（Command Link）**功能，通过 `LINKADDR` 指针获取下一个命令。
- **触发保留**：如果在当前任务结束到下一个链接任务开始之间收到了额外的触发请求，该请求会保持悬起（Pending），确保不会丢失任何触发事件。
- **暂停检查**：若 `DONEPAUSEEN` 置位，通道在完成任务后进入暂停状态，直到接收到 `RESUMECMD`。

---

### 5.6.2 命令自动重启 (Automatic restart of commands)

自动重启功能允许循环执行同一个命令，省去了重新加载相同配置的开销，从而提高效率。

**重启模式：**

- **无限循环 (`CMDRESTARTINFEN = 1`)**：命令将无限次重启，直到通道被手动禁用或停止。
- **计数循环 (`CMDRESTARTCNT > 0`)**：按设定次数执行重启。每执行一次，计数器减 1，直到减为 0 为止。

寄存器重载 (REGRELOADTYPE)：

当自动重启使能时，源地址、目的地址和传输尺寸（Size）会根据 REGRELOADTYPE 的设置决定是否恢复初始值：

- **重载**：每一轮循环都从最初定义的起始地址开始。
- **不重载**：下一轮循环的起始地址将基于上一轮结束时的地址继续（即地址累加）。

### 5.6.3 错误处理 (Error Handling)

当 DMA-350 通道在操作过程中检测到错误时，通道会立即停止运行。此时，通道状态会转换到 **DISABLED**（`ch_enabled = 0`），并置位状态寄存器中的错误标志位 `STAT_ERR`。

如果设置了中断使能 `INTREN_ERR`，则会触发 `INT_ERR` 中断。软件可以通过查看 **`CH(x)_ERRINFO`** 寄存器来获取具体的错误原因。

---

#### 1. 错误类型总览 (Table 5-8)

| 错误类型             | 错误信息字段                         | 描述                                                          |
| -------------------- | ------------------------------------ | ------------------------------------------------------------- |
| **总线错误**         | `BUSERR`                             | 数据传输或命令链接获取期间，AXI5 或 AXI-Stream 接口发生错误。 |
| **配置错误**         | `CFGERR`                             | 即将执行的命令寄存器配置无效，或接收到无效的命令链接头。      |
| **触发输入选择错误** | `SRCTRIGINSELERR`, `DESTRIGINSELERR` | 所选的触发输入端口已被其他使能通道或触发矩阵占用。            |
| **触发输出选择错误** | `TRIGOUTSELERR`                      | 所选的触发输出端口已被占用。                                  |
| **流溢出/异常错误**  | `STREAMERR`                          | AXI-Stream 接口遇到错误（如提前终止或超时）。                 |

---

#### 2. 错误原因详细字段 (Table 5-9)

| 位偏移 | 字段名称           | 详细描述                                                          |
| ------ | ------------------ | ----------------------------------------------------------------- |
| [26]   | **CFGCONFLERR**    | **配置冲突**：配置寄存器中的设置相互矛盾。                        |
| [25]   | **REGVALERR**      | **寄存器非法值**：某个配置寄存器被设置为非法数值。                |
| [24]   | **LINKHDRERR**     | **链接头错误**：读取了无效的命令链接头信息。                      |
| [21]   | **STRINEARLYTERM** | **流提前终止**：Stream In 接口比 Stream Out 接口先结束。          |
| [20]   | **STRINOVERRUN**   | **流过载**：AXI 写事务已完成但 Stream In 仍忙碌且未收到 `tlast`。 |
| [19]   | **STRINTSTRBERR**  | **流 TSTRB 错误**：在 AXI-Stream In 上检测到无效的 `tstrb` 信号。 |
| [18]   | **AXIRDPOISERR**   | **AXI 读 Poison 错误**：检测到 AXI 读 Poison 属性。               |
| [17]   | **AXIWRRESPERR**   | **AXI 写响应错误**：AXI 写操作收到错误响应。                      |
| [16]   | **AXIRDRESPERR**   | **AXI 读响应错误**：AXI 读操作收到错误响应。                      |

---

#### 3. 错误分类详解

##### AXI5 总线错误

一旦检测到总线错误（如 AXI `SLVERR` 或 `DECERR`），当前命令**立即停止**。

- **数据处理**：与该错误相关的数据会被丢弃。
- **清理机制**：所有正在进行的（Outstanding）事务都会被完成，但它们的数据也会被丢弃，确保总线协议的一致性。

##### 配置错误 (Checked before execution)

硬件在执行数据传输前会先自检。如果发现以下问题，**不会启动**任何总线传输：

- **非法字段值 (REGVALERR)**：例如 `TRANSIZE` 超过了总线数据位宽。
- **设置不兼容 (CFGCONFLERR)**：例如在不支持的传输模式下启用了模板化传输（Templated transfer）或流接口。

##### 触发选择错误

发生在“触发分配状态”。如果所选端口被占用或安全属性不匹配，命令会停止。

- **常见原因**：源端和目的端错误地选择了同一个触发端口。

##### AXI-Stream 接口错误

- **流过载 (Overrun)**：目的地计数器 `DESXSIZE` 已经减到 0，但外部引擎发回的 Stream 还没给 `tlast`。此时 DMAC 会断言 `flush` 信号来丢弃剩余数据。
- **提前终止**：外部引擎发出的 `tlast` 信号早于预期的传输规模。

### 5.6.4 命令执行状态报告

在 DMA 命令执行后，软件可以读取 X、Y 尺寸寄存器以及地址寄存器的内容。

这些寄存器的内容取决于 DMA 命令停止的方式：

- **达到 DONE 状态（命令执行已完成）：**
  - **尺寸寄存器**均为 0，读端或写端均无待完成的事务。
  - **地址寄存器**包含“下一个”地址，其值就如同该已完成命令之后紧跟着相同类型的后续 DMAC 操作一样。
- **处于 STOPPED/PAUSED 状态（命令执行在完成前被停止或暂停）：**
  - **尺寸寄存器**包含当前未完成事务的实际坐标（Coordinates）。
  - **地址寄存器**包含下一个未完成事务的地址。

在 **STOPPED/PAUSED** 状态下，地址和尺寸寄存器的值仅是实际命令执行状态的**近似值**，可能并不包含精确位置。它们仅作为命令执行大约在何处被中止的提示。

如果暂停发生在**命令链接（Command Link）**执行期间，读回的寄存器可能包含不一致的命令信息，因为当 DMA 进入暂停（PAUSED）状态时，并非所有寄存器都已完成更新。

---

#### 命令结束时的地址寄存器

在命令结束时，地址寄存器包含相同类型的下一个未完成 DMAC 事务的地址。如果命令已完成，则下一个地址指向：如果该命令包含更多事务，则本该用于该事务的地址。

为了清晰起见，下表涵盖了主要情况：

**表 5-10：读操作 (Read operations)**

| **读模式**           | **DMA 命令最后一行结束** | **DMA 命令非最后一行结束** | **DMA 命令行中途** |
| -------------------- | ------------------------ | -------------------------- | ------------------ |
| **1D 无回绕 (Wrap)** | `Incr_addr`              | N/A                        | `Incr_addr`        |
| **1D 有回绕 (Wrap)** | `Cur_line_start_addr`    | N/A                        | `Incr_addr`        |
| **2D 且 Y 无回绕**   | `Incr_line_start_addr`   | `Incr_line_start_addr`     | `Incr_addr`        |
| **2D 且 Y 有回绕**   | `First_line_start_addr`  | `Incr_line_start_addr`     | `Incr_addr`        |

当 X 类型为回绕（Wrap），即 1D 有回绕或 2D 且 Y 有回绕时，读操作有两种可能的行结束情况：

- 当**仅读行**结束时，下一个地址始终是该行的起始地址。
- 当**写行**结束时（无论读行是否同时结束），下一个地址由上表中的读操作规则确定。

由于 1D 命令仅由一行组成，因此它也被视为最后一行。

**表 5-11：写操作 (Write operations)**

| **写模式**           | **DMA 命令最后一行结束** | **DMA 命令非最后一行结束** | **DMA 命令行中途** |
| -------------------- | ------------------------ | -------------------------- | ------------------ |
| **1D 无回绕 (Wrap)** | `Incr_addr`              | N/A                        | `Incr_addr`        |
| **1D 有回绕 (Wrap)** | `Incr_addr`              | N/A                        | `Incr_addr`        |
| **2D 且 Y 无回绕**   | `Incr_line_start_addr`   | `Incr_line_start_addr`     | `Incr_addr`        |
| **2D 且 Y 有回绕**   | `Incr_line_start_addr`   | `Incr_line_start_addr`     | `Incr_addr`        |

---

#### 术语定义

- **`Incr_addr`**：根据增加（Increment）或模板（Template）配置以及配置的 `TRANSIZE` 递增上一个 DMAC 事务的地址。
- **`Incr_line_start_addr`**：根据 Y 跨度（Stride）和 `TRANSIZE` 配置递增当前行的起始地址。地址指向下一行的第一个字节。
- **`Cur_line_start_addr`**：地址指向当前行的起始字节。
- **`First_line_start_addr`**：地址指向当前 2D DMA 命令中第一行的第一个字节。

---

#### 具体示例

**1. 读/写 1D 无回绕命令：**

- 配置：X size = 5，Transize = 1 byte，Start address = 0x0。
- 结果：如果最后一次事务地址是 0x4（第 5 个字节），则软件读回的地址将指向 **0x5**。

**2. 读/写 1D 有回绕命令：**

- 配置：Source X size = 5，Dest. X size = 7，Transize = 1 byte，Start address = 0x0。
- 读操作：如果最后一次读事务地址是 0x4（第 5 个读字节），读地址将回绕并指向 **0x0**。
- 读操作：如果最后一次读事务地址是 0x1（第 7 个读字节，即目的地已填满），读地址指向 **0x0**。

**3. 读/写 2D 无回绕命令：**

- 配置：X size = 5，Y size = 3，Y stride = 0x10，Start address = 0x0。
- 结果：如果最后事务地址是 0x24（第 3 行第 5 字节），读回地址指向 **0x30**（下一行的起点）。

---

#### 尺寸寄存器 (Size Registers)

- **正常结束**：所有尺寸寄存器均为 0。
- **中途停止/总线错误**：
  - **1D 命令**：X 寄存器包含剩余未发送的事务数量（以 `TRANSIZE` 为单位）。
  - **2D 命令**：X 和 Y 寄存器包含下一个未发送事务的 X、Y 坐标。
    - 行中途：X 包含行内剩余数据。
    - 行结束：可能显示 `Y:当前行, X:0` 或 `Y:下一行, X:总宽度`。

#### 硬件优化逻辑

为了减少不必要的总线读取，DMAC 会自动进行以下优化：

- 如果 X 类型为 WRAP 或 FILL，且 **目的端 X 尺寸 < 源端 X 尺寸**，则源端 X 尺寸会被强制设为目的端 X 尺寸。
- 同理，如果源端 Y 尺寸过大，也会被优化对齐至目的端。

#### 空命令后的状态

如果命令中某一方（读或写）未被激活，则该侧的地址保持不变。任务完成后，未激活侧的尺寸寄存器将变为 0。

### 5.7 命令链接 (Command Linking)

**命令链接**功能允许 DMA 通道通过从系统内存自动加载后续命令到配置寄存器，从而执行连续的操作。这一特性使得 DMA-350 在单次 DMA 事务中组合多个命令时非常灵活。

每个命令都可以定义新的传输参数、触发行为和中断设置。通过合理设计命令链，可以实现复杂的传输任务。

- **描述符 (Descriptors)**：命令由存储在内存中的描述符定义。
- **链接地址 (LINKADDR)**：通道使用存储在链接寄存器中的指针地址来获取描述符。
- **启动方式**：第一个命令必须**手动**直接在通道寄存器中设置以启动链条。如果需要，第一个命令可以是“空命令”，仅用于指向内存中第一个非空命令的位置。
- **增量更新 (Delta Update)**：描述符包含一个**表头 (Header)**，指定哪些寄存器需要更新。如果某些参数（如触发设置）保持不变，则无需重新加载，从而减少总线传输次数。
- **结束条件**：当链条中某个命令的 `LINKADDREN` 位（第 0 位）未置位时，命令链执行结束。

#### 链条控制逻辑：

- **停止 (Stop)**：设置 `CH(x)_CMD.DISABLECMD` 位可以干净地停止命令链。当前执行的命令会完成，但下一个命令不会被加载。这常用于停止无限循环的链接。
- **暂停 (Pause)**：行为与单次命令暂停一致。恢复后，当前命令继续执行，随后继续命令链接。
- **异常停止**：如果命令链中的某个命令停止，链条的剩余部分将被取消。

---

### 5.7.1 命令结构 (Command Structure)

命令以**链表 (Linked List)** 数据结构存储在系统内存中。每个描述符包含需要更新的配置信息以及指向下一个描述符的指针。

#### 链接指针寄存器 (`CH(x)_LINKADDR`)

- 存储下一个命令的地址。
- **`LINKADDREN` (bit 0)**：必须置 1 表示链接有效。若为 0，则代表这是链条的最后一个命令。

#### 链接命令链结构

命令描述符在内存中是以 **32 位字 (32-bit words)** 构成的连续数组。

1. **表头字 (Header Word)**：描述符的第一个 32 位字。

   - **位图 (Bitmap)**：指示哪些寄存器需要更新。
   - **REGCLEAR 标志**：
     - 若置位：在更新前清除所有可由链接修改的配置寄存器。
     - 若未置位：未在位图中指定的寄存器将保留上一个命令的设置（即继承之前的状态）。

### 5.7.1 命令链接表头与结构详解

在 DMA-350 中，**命令链接（Command Linking）**通过一种“位图（Bitmap）”机制来减少总线开销。每个描述符的第一个字是 **表头（Header）**，它告诉 DMA：后面跟着的哪些数据需要更新到哪个寄存器。

---

#### 表 5-12：命令链接表头（Header）位域定义

| **位偏移**  | **名称**                    | **描述 (更新对应的寄存器)**              |
| ----------- | --------------------------- | ---------------------------------------- |
| **0 (LSB)** | **REGCLEAR**                | **在更新前清除所有寄存器**（恢复默认值） |
| 2           | INTREN                      | 中断使能寄存器                           |
| 3           | CTRL                        | 通道控制寄存器                           |
| 4 / 5       | SRCADDR / HI                | 源起始地址 / 高位（40 位地址用）         |
| 6 / 7       | DESADDR / HI                | 目的起始地址 / 高位                      |
| 8 / 9       | XSIZE / HI                  | X 方向传输尺寸 / 高位                    |
| 10          | SRCTRANSCFG                 | 源端传输配置                             |
| 11          | DESTRANSCFG                 | 目的端传输配置                           |
| 12          | XADDRINC                    | X 地址增量配置                           |
| 13          | YADDRSTRIDE                 | Y 地址跨度（Stride）                     |
| 14          | FILLVAL                     | 填充值配置                               |
| 15          | YSIZE                       | Y 方向传输尺寸                           |
| 16          | TMPLTCFG                    | 模板配置                                 |
| 17 / 18     | SRCTMPLT / DESTMPLT         | 源/目的模板数据                          |
| 19 / 20     | SRCTRIGINCFG / DESTRIGINCFG | 源/目的触发输入配置                      |
| 21          | TRIGOUTCFG                  | 触发输出配置                             |
| 22 / 24     | GPOEN0 / GPOVAL0            | GPO 使能与输出值                         |
| 26          | STREAMINTCFG                | AXI-Stream 接口配置                      |
| 28          | LINKATTR                    | 链接属性配置                             |
| 29          | AUTOCFG                     | 自动重启配置                             |
| **30**      | **LINKADDR**                | **下一个描述符的链接地址（低 32 位）**   |
| 31 (MSB)    | LINKADDRHI                  | 链接地址高位                             |

> [!CAUTION]
>
> 硬性规定：表头中必须至少有 1 位设为 1。如果全为 0，硬件会报 配置错误 并停止执行。数据跟随表头的顺序必须严格遵守 从 LSB 到 MSB。

---

#### 命令描述符在内存中的布局规则

如果表头指示要更新 5 个寄存器，那么内存中紧跟在该表头后的 5 个 32-bit 字就是这些寄存器的新值。

### 5.7.2 加载命令 (Loading commands)

DMA-350 使用执行数据传输的同一套 **AXI 管理器接口**来从系统内存加载命令描述符。

#### 命令描述符获取属性 (Fetch Attributes)

- **AXI ID**：获取命令时使用的 AXI ID 与数据传输时相同。
- **传输大小 (`TRANSIZE`)**：固定为系统的 `DATA_WIDTH`（数据总线宽度）。
- **突发长度 (`MAXBURSTLEN`)**：始终设置为最大值，以优化获取效率。
- **安全性与权限**：
  - **严格隔离**：非安全通道只能加载非安全命令；安全通道只能加载安全命令。
  - 获取过程忽略 `CH(x)_SRCTRANSCFG` 中的设置，直接继承通道自身的安全/特权状态。
- **AXI 总线特征识别**：
  - **指令访问**：`arprot_m(x)[2]` 被置为 **1**。
  - **专用信号**：增加了一个额外的 User 信号 **`arcmdlink_m(x)`**，明确指示该读事务属于命令描述符获取。

#### 配置寄存器更新

- 获取过程按序进行：首先读取 **表头字 (Header word)**。
- 随后根据位图指示，依次读取并更新对应的配置寄存器。

---

### 5.7.3 自动引导特性 (Automatic boot feature)

为了加速系统启动，DMA-350 实现了 **autoboot** 功能。该功能可以在复位释放后自动将第一个 DMA 命令加载到 **通道 0** 并开始执行。

#### 启用 Autoboot

Autoboot 由一组专用的硬件输入信号配置。为了确保引导成功，以下信号必须在**解除设备复位之前**保持稳定，直至引导命令获取开始：

- **`boot_en`**：置 1 启用 autoboot。
- **`boot_addr`**：引导命令描述符的起始地址。
- **`boot_memattr`**：获取描述符时的 AXI 内存属性。
- **`boot_shareattr`**：获取描述符时的 AXI 可共享性属性。

> **注意**：如果使用了安全扩展（Security Extension），通道 0 默认以**安全状态**启动，因此 `boot_addr` 必须指向安全地址区域。

#### Autoboot 执行流程

1. **复位释放**：DMA-350 退出复位且两个 LPI 通道进入活跃状态。
2. **采样信号**：采样上述硬件输入信号。
3. **初始化**：硬件将预设的 `boot_addr` 写入通道 0，作为初始的“空链接命令”。
4. **获取与执行**：通道 0 获取 `boot_addr` 指向的描述符，更新寄存器，并开始执行任务。
5. **状态监控**：可以通过 `ch_enabled[0]` 信号追踪引导进度。

### 5.8 仲裁机制 (Arbitration)

当多个通道需要同时使用单个总线接口发送数据时，需要进行通道仲裁。DMA-350 通过寄存器 `CH_CTRL.CHPRIO` 设置通道优先级。该优先级不仅连接到 AXI 总线的 QoS 位，还直接影响内部仲裁算法。

**核心规则：**

- **软件责任**：DMAC 本身无法感知任务的时间紧迫性，因此软件必须合理分配优先级。
- **修改约束**：仅当通道处于 **IDLE（空闲）** 或 **STOPPED（停止）** 状态时，软件才能更改仲裁配置。

---

### 5.8.1 仲裁请求触发条件

通道只有在满足特定条件时才会发起仲裁请求：

- **读操作请求条件：**
  1. 通道状态机（FSM）已准备好下一组读地址及所有控制信息。
  2. **数据 FIFO 有足够空间**存储完整的读响应数据。
- **写操作请求条件：**
  1. 通道 FSM 已准备好下一组写地址及控制信息。
  2. **数据 FIFO 已存有完整的写突发（Burst）数据**。

> **IC 设计细节：** 只有在 FIFO 预读了完整突发后才允许发起写仲裁。这种设计方案通过消除写操作对实时入流数据的依赖，有效避免了读写之间的**循环依赖（死锁）**。

---

### 5.8.2 仲裁方案：最近最少获权 (LRG)

DMA-350 采用 **LRG (Least-Recently Granted)** 算法，并结合了**固定优先级**与**轮询（Round-robin）**两层架构。

#### 1. 仲裁双层架构

仲裁逻辑根据通道优先级分为两个层级：

- **优先级层（Priority-based Layer）**：在不同优先级的通道之间进行仲裁。优先级高者总是胜出（由 AXI `arqos` / `awqos` 属性指示）。
- **轮询层（Round-robin Layer）**：在相同优先级的通道之间进行仲裁。采用 LRG 算法，确保公平性。

#### 2. LRG 算法逻辑

- **固定优先级优先**：只要存在高优先级请求，低优先级通道就会被阻塞。这保证了高优先级任务的**确定性执行**。
- **同级公平性**：当多个通道优先级相同时，LRG 方案会记录获权历史，将总线权限分配给那个“最近最久没有获得过权限”的通道。
- **逐个突发仲裁**：仲裁发生在**每一个突发（Burst）**之后，这意味着总线资源在每一轮传输后都会重新评估分配。

---

### 5.8.3 饥饿问题 (Starvation)

在某些特殊情况下，低优先级通道可能会发生“饥饿”：

- **产生原因**：如果高优先级通道被配置为无限循环的命令链接，或者软件频繁触发高优先级任务，总线时间片可能被完全占据。
- **命令链接开销**：命令描述符的读取（Command Link Fetch）使用与数据读取相同的优先级和仲裁逻辑。
- **软件对策**：DMAC **没有**内置硬件级的公平分片（Fair Share）算法来强行保护低优先级通道。软件设计者需要利用高优先级通道的“空闲间隙”来确保整体进度：
  - 等待触发（Trigger）的间隙。
  - 等待 AXI 响应（Response）到达的潜伏期。
  - 通过 APB4 进行重配置的阶段。
  - 读取新链接描述符的周期。

## 5.9 DMAC 电源管理与控制

本节描述了 DMA-350 的电源管理与配置。

### 5.9.1 电源管理

DMA-350 拥有独立的分离式电源与时钟管理系统。

#### 5.9.1.1 电源 P-Channel

DMA-350 使用一个完整的 **LPI P-Channel** 进行电源管理。该特性的目的是在设备非活跃使用时，能够进入低功耗状态（切断电源）以降低功耗。电源 P-Channel 用于控制 DMAC 逻辑的电源状态。

通过 P-Channel 接口可以请求以下四种电源状态，任何其他状态请求都将被拒绝：

- **On**（开启）
- **Warm reset mode**（热复位模式）
- **Full retention mode**（全保持模式）
- **Off**（关闭）

DMAC 在 P-Channel 接口上的电源管理场景非常简单。当 DMAC 处于活跃状态（Active）时，任何电源静默请求都会被拒绝，操作继续进行。**热复位模式（Warm reset mode）**请求会暂停所有正在进行的通道操作，从热复位模式退出到开启状态会恢复通道操作。当 DMAC 处于主动等待（Actively waiting）事件时，接受进入**全保持模式（Full retention mode）**的请求，但拒绝进入关闭（Off）状态。当 DMAC 处于不活跃状态（Inactive）时，接受进入关闭状态的请求。在进入关闭状态之前，FIFO 会被排空，寄存器值不会被保留。

可以通过配置寄存器 **NSEC_CTRL** 和 **SEC_CTRL** 中的 **DISMINPWR** 字段禁用进入更低功耗模式（全保持、关闭）。如果 **DISMINPWR** 设置的最低电源状态高于请求的状态，且至少有一个通道分别配置为非安全或安全，则电源状态请求将被拒绝。

可以通过配置寄存器 **NSEC_CTRL** 和 **SEC_CTRL** 中的 **IDLERETEN** 字段，禁用或启用 DMAC 在主动等待状态下进入全保持模式。如果 **IDLERETEN** 设置为禁用，且请求的状态是全保持模式，且至少有一个非安全或安全通道（根据字段的安全属性）正在等待事件，则电源状态请求将始终被拒绝。

#### 5.9.1.2 时钟 Q-Channel

DMA-350 使用一个完整的 **LPI Q-Channel** 进行时钟管理。该特性的目的是在设备非活跃使用时关断时钟以降低功耗。时钟 Q-Channel 用于开启或关闭 DMAC 逻辑的时钟。

Q-Channel 接口控制 DMAC 的时钟管理。当 DMAC 处于活跃状态时，时钟静默请求会被拒绝，操作继续。当 DMAC 处于主动等待事件或不活跃状态时，静默请求被接受，时钟可以被关断。

---

### 5.9.2 配置

DMA-350 通过配置寄存器进行设置。这些寄存器分为若干帧，每帧占据 256 字节的地址空间。整个 DMA 单元占用 **8kB** 的配置地址空间。

#### 5.9.2.1 DMA 单元配置

以下四个寄存器帧与 DMA 单元相关：

- **安全配置寄存器帧 (DMASECCFG)**：配置每个 DMA 通道的安全与特权属性，以及外部触发端口的安全属性。
- **安全控制寄存器帧 (DMASECCTRL)**：包含影响所有配置为“安全”通道的状态和控制寄存器。
- **非安全控制寄存器帧 (DMANSECCTRL)**：包含影响所有配置为“非安全”通道的状态和控制寄存器。
- **信息寄存器帧 (DMAINFO)**：提供有关 DMA 单元能力和参数的信息。

#### 5.9.2.2 通道配置

每个 DMA 通道拥有独立的寄存器帧。**配置寄存器仅在通道未使能时可写**。当 **CH(x)\_CMD** 寄存器中的 **ENABLECMD** 位置位时，设置在整个命令执行期间被冻结。

**配置命令的准则：**

1. 寄存器字段必须仅包含允许的值（否则导致 **REGVALERR**）。
2. 设置必须描述一个有效的命令，即不存在冲突参数（否则导致 **CFGCONFLERR**）。

**配置通道命令的步骤：**

1. **CH(x)\_CTRL 寄存器**：设置通道优先级、传输单元大小 (**TRANSIZE**)、传输类型 (**XTYPE/YTYPE**)、功能选择（触发/GPO/流接口）以及完成类型。
2. **源/目的起始地址**：由 **SRCADDR/SRCADDRHI** 和 **DESADDR/DESADDRHI** 定义。
3. **源/目的尺寸及 Y 步幅**：由 **XSIZE** 寄存器定义。若为 2D 传输，需设置 **YSIZE** 和 **YADDRSTRIDE**。
4. **源/目的地址增量**：由 **CH(x)\_XADDRINC** 定义（支持补码形式的负数或零）。
5. **总线属性**：在 **CH(x)\_SRCTRANSCFG/DESTRANSCFG** 中配置安全、特权、内存属性、可共享性及最大突发长度 (**MAXBURSTLEN**)。
6. **填充值**：若传输类型为 `fill`，在 **CH(x)\_FILLVAL** 中设置。
7. **模板传输**：在 **CH(x)\_TMPLTCFG** 等寄存器中设置模式和尺寸。
8. **触发配置**：若使用触发，需配置 **TRIGINTYPE**（类型）、**TRIGINMODE**（模式：命令或流控）、**TRIGINSEL**（端口选择）及 **TRIGINBLKSIZE**（块大小）。
9. **GPO 设置**：若使用 GPO，配置输出值及使能掩码。
10. **流接口**：若使用 AXI-Stream，配置 **STREAMTYPE**。
11. **自动重启**：设置 **CMDRESTARTCNT** 或使能 **CMDRESTARTINFEN**（无限重启），并选择重载类型。
12. **命令链接**：使能 **LINKADDREN** 并设置描述符地址 **LINKADDR/LINKADDRHI** 及总线属性。

---

### 5.9.3 空命令 (Empty Commands)

空命令是描述有效但**不产生实际数据搬运**的命令。它们可用于启动链接链、设置 GPO 或利用触发功能进行通道同步。

**以下情况会导致 AXI5 接口无数据读取：**

- 显式设置 `XTYPE = 'disable'`。
- 选择 `Stream in only` 模式。
- 源端配置为 AXI 但尺寸（Size）设为 0。
- AXI 到 AXI 模式但目的端尺寸设为 0。

**以下情况会导致 AXI5 接口无数据写入：**

- 显式设置 `XTYPE = 'disable'`。
- 选择 `Stream out only` 模式。
- 目的端配置为 AXI 但尺寸设为 0。
- AXI 到 AXI 模式但无数据产生（源尺寸为 0 且无填充模式）。

**推荐的显式空命令配置方法是将 XTYPE 设置为 `disable`。**

---

### 5.9.4 配置错误 (Configuration Errors)

**1. 非法设置导致的错误 (REGVALERR)：**

- **TRANSIZE** 大于总线位宽。
- 触发选择器（SEL）值超出有效范围。
- 在硬件不支持触发端口的情况下配置硬件触发类型。

**2. 冲突设置导致的错误 (CFGCONFLERR)：**

- **流控触发模式仅支持 1D**：即使选择了 2D 传输，对应侧的 **YSIZE** 必须为 1。
- **流接口不支持流控触发**。
- **源端流控触发模式下不允许使用回绕（Wrap）传输**。
- **流控触发模式必须配置数据传输**（不能是空传输）。
- **流接口不支持的传输类型**：例如某些 Wrap 和 Fill 的组合。
- **模板传输（Templated transfers）不允许与 2D 传输配合使用**。

### 5.9.3 使用 CTI 停止和重启 DMA

DMA-350 可以通过 **CTI（交叉触发接口）** 接口进行调试目的的停机。

- **停机流程**：当 CTI 的 `halt_req` 信号接收到高电平时，会启动所有安全和非安全通道的暂停操作。
- **确认信号**：当所有通道在停机请求后达到“暂停”或“未使能”状态时，硬件会发送一个 `halted` CTI 脉冲信号。
- **重启流程**：DMAC 进入暂停状态后，会等待 CTI `restart_req` 信号的高电平。收到该信号后，所有 DMA 通道将恢复到停机请求之前的状态。

**CTI 请求的忽略情况**：

- 在之前的停机请求之后、DMAC 返回正常运行之前，再次收到的 `halt_req` 会被忽略。
- 在收到停机请求之前，收到的 `restart_req` 会被忽略。在接收到一个有效的 `restart_req` 高电平后，随后的电平变化将被忽略。

暂停方式的结合：

来自 CTI 的停机请求会与硬件暂停信号（allch_pause_req）以及软件发起的全局暂停（allchpause）相结合。可以通过这三种方法中的任何一种来暂停 DMA 通道。

---

### 5.10 初始化

在设置通道进行内存传输之前，必须先配置 DMAC，以设定每个通道及其关联资源的安全（Security）和特权（Privilege）属性。

- **保护机制**：配置完成后，通道配置寄存器将受到保护，防止恶意访问。安全配置可以被**锁定**，直到下一次 DMAC 复位，以进一步保护安全设置。
- **动态调整**：通道的特权设置可以在通道处于 **IDLE** 状态时进行调整。
- **自动清除**：当通道的安全或特权设置发生更改时，寄存器设置会自动清除。
- **推荐做法**：建议通过“先写入再读回”预期状态的序列来执行安全或特权更改，以确保更改成功。

自动引导逻辑：

DMAC 在复位后检查 boot_en 端口。如果开启了自动引导（Autoboot），DMAC 会在任何 APB4 配置发生前，将引导地址设置为通道 0 的第一个链接地址并使能该通道。当 DMAC 启用了安全扩展时，通道 0 与其他所有通道一样被设置为“安全”状态，因此只能从内存中获取安全命令。

---

### 5.11 中断操作

每个通道都有独立的中断来指示通道内的状态变化。此外，还有 **DMA 单元级中断**来显示单元级的状态变化。软件可以使能、禁用或清除这些中断。

- **安全隔离**：当同时使用安全和非安全中断时，每个中断都有运行在相应安全世界的处理程序（Handler）。
- **中断属性**：当通道配置为“安全”时，其通道中断也被视为安全中断。

#### 表 5-16：非安全（Non-secure）DMA 级别中断信号源

| **中断源**            | **描述**                                                                                              |
| --------------------- | ----------------------------------------------------------------------------------------------------- |
| **chintrstatus0**     | 归并（Collated）的所有非安全通道中断标志。                                                            |
| **intr_anychintr**    | 组合非安全中断。当 `NSEC_CTRL.INTREN_ANYCHINTR` 置 1 时，结合了其他非安全中断源和所有非安全通道中断。 |
| **intr_allchidle**    | 当所有非安全通道从非空闲状态返回 **IDLE** 状态时触发。复位后不会立即断言。                            |
| **intr_allchstopped** | 当最后一个非安全通道进入停止（Stopped）状态时触发。                                                   |
| **intr_allchpaused**  | 当最后一个非安全通道进入暂停（Paused）状态时触发。                                                    |

---

#### 表 5-17：安全（Secure）DMA 级别中断信号源

| **中断源**            | **描述**                                                                                       |
| --------------------- | ---------------------------------------------------------------------------------------------- |
| **chintrstatus0**     | 归并的所有安全通道中断标志。                                                                   |
| **intr_anychintr**    | 组合安全中断。当 `SEC_CTRL.INTREN_ANYCHINTR` 置 1 时，结合了其他安全中断源和所有安全通道中断。 |
| **intr_allchidle**    | 当所有安全通道从非空闲状态返回 **IDLE** 状态时触发。                                           |
| **intr_allchstopped** | 当最后一个安全通道进入停止状态时触发。                                                         |
| **intr_allchpaused**  | 当最后一个安全通道进入暂停状态时触发。                                                         |

安全违规中断：

提供 irq_sec_viol_err 中断信号，用于通知安全实体发生了针对 DMA 寄存器访问的安全违规。当 SECEXT_PRESENT（安全扩展存在）设为 0 时，该信号不存在。

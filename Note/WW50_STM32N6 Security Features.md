### 3 系统安全 (System security)

**3.1 关键安全特性 (Key security features)**

- 利用 Arm Cortex-M55 的 **TrustZone** 技术实现安全隔离
- 利用带防火墙功能的 Cortex-M55 **MPU** 技术实现操作系统和动态用户隔离
- **多租户支持**：可配置防火墙，允许受信任的操作系统确保不同 AI 提供商安装的软件应用程序无法使用 NPU 引擎或 DMA 引擎访问彼此的数据
- 客户密钥和固件的安全烧录 (Provisioning)
- **安全从 ROM 启动**：验证并解密从外部闪存加载的或通过 UART、USB、I2C、SPI、FDCAN 或 JTAG 下载的镜像
- **非易失性反熔丝 (Antifuse) 存储器**，例如用于存储：
  - 硬件唯一密钥 (**HUK**)，直接硬连线至抗 DPA 攻击的 AES 引擎
  - 用于客户密钥安全烧录的私钥
  - 客户烧录的固件签名和加密密钥
  - 客户烧录的用于管理退料分析 (**RMA**) 的密钥
  - 用于密钥/证书吊销、更新、出厂重置的不可逆计数器
- **电池供电的易失性存储器**，例如用于存储：
  - 客户烧录的秘密启动硬件密钥 (**BHK**)，直接硬连线至抗 DPA 攻击的 AES 引擎，在发生篡改时自动擦除
  - 防回滚计数器
- 在非易失性存储器（例如外部闪存）中烧录 AES 密钥，使用源自 HUK 的不可见设备唯一密钥进行加密：烧录的 AES 密钥在设备上永远不可见，仅直接用于 AES 硬件加速器以加密和解密数据
- **通用加密加速**：
  - 两个 AES 256 位引擎，支持 ECB、CBC、CTR、GCM 和 CCM 链接模式：一个引擎具备抗 DPA 能力及侧信道防御措施，另一个为无抗 DPA 能力的快速实现引擎
  - 哈希 (HASH) 处理器，支持 SHA-2 安全哈希
  - PKA（公钥加速器），用于 RSA/DH（最高 4096 位）和 ECC（最高 640 位）：在处理机密信息时实施侧信道防御措施和缓解技术
  - RNG（真随机数生成器），通过 NIST SP800-90B 预认证
- **存储器加解密引擎**：用于外部存储器数据的实时 (on-the-fly) 解密，实现密钥派生函数以增强对侧信道攻击 (**SCA**) 的防护
- **NPU 总线接口上的低延迟加密引擎**：允许 AI 数据以加密格式存储在外部和内部存储器中
- 利用 **HDPL**（隐藏保护级别）通过硬件强制执行的 Arm PSA 时间隔离
- **基于证书的调试认证方案**：赋予调试器在授权安全级别下的权限
- **主动防篡改及针对温度、电压和频率攻击的防护**：
  - 多达 7 个防篡改引脚（输入、输出），在所有电源模式下均可用
  - 一旦确认检测到篡改，立即擦除电池供电的易失性机密信息

### 3.2 安全启动 (Secure boot)

在应用程序复位 (Reset) 后，Cortex-M55 始终从片上 ROM 的起始位置启动。该 ROM 代码用于验证并解密加载到内部存储器中的镜像，加载源可以是外部闪存，也可以通过 UART、USB、I2C、SPI、FDCAN 或 JTAG 下载。

启动流程由**熔丝 (Fuses)** 定义的生命周期状态决定。系统复位时，硬件读取熔丝状态，将设备分为两类：**BSEC-open (开放)** 或 **BSEC-closed (封闭)**。

分支 1：BSEC-open 状态

> 场景：设备制造初期，通过 RMA 流程退回分析

- 启动类型：非安全启动
- 调试功能：启用
- 机密访问（机密熔丝和 ROM 安全区域）：禁用

分支 2：BSEC-closed 状态

> 场景：设备交付给客户时的默认状态。

- 调试功能：禁用
- 启动类型：安全启动
- Boot ROM 查询额外的熔丝以确定精确的生命周期状态，进入以下分支

- 分支 2.1 ：`secure_boot` 熔丝未熔断 (开发阶段)
  - 分支 2.1.1： `DEV_BOOT` 引脚置位
    - 调试功能：启用
    - 机密访问：禁用
  - 分支 2.1.2： `DEV_BOOT` 引脚未置位
    - 执行策略：直接执行镜像 (不校验签名)
- 分支 2.2：`secure_boot` 熔丝已熔断 (量产安全阶段)
  - 调试功能：禁用
  - 启动类型：安全启动
  - 执行策略：仅执行签名与解密验证通过的镜像

STMicroelectronics 提供签名工具，允许客户创建经过签名和加密的启动镜像。该启动镜像有时被称为 **FSBL**（第一阶段引导加载程序）或 **uRoT**（可更新信任根固件）。

## 3.3 安全烧录 (Secure provisioning)

1. ST 提供根安全服务扩展镜像（RSSe），该镜像由硬编码密钥验签
2. ST 预置设备唯一密钥（device-unique key）
3. 客户通过 RSSe，预置用户密钥，预置过程由设备唯一密钥确保安全。
   - 可烧录可计数，需要烧录多少个芯片，就需要生成并烧录多少由设备唯一私钥加密的用户密钥
   - 防克隆，防止工具之读取向芯片 A 烧录的加密包，灌入芯片 B 使用。
4. 每次启动时，用户启动镜像由用户密钥验签与解密。 5. 从镜像包读取公钥与 fuse 中的用户公钥对比 6. 对比通过后，使用验证通过的公钥对镜像包验签 7. 使用固件加密密钥（用户密钥）解密常量（镜像解密密钥密文），得到派生密钥（镜像解密密钥） 8. 使用派生密钥（镜像解密密钥）解密用户启动固件镜像
5. Boot ROM 支持多达八次的固件签名密钥不可逆吊销。

**硬编码密钥**
所有产品有相同的硬编码密钥，硬编码私钥泄露将导致整批产品安全风险

**根安全服务扩展镜像**
功能：实现安全固件安装（SFI）功能
可信根：硬编码的公钥
硬编码的公钥可能被攻击者获取，但硬编码公钥仅能用来认证 RSSe，不能用来伪造 RSSe

**设备唯一密钥，device-unique key**
烧录位置：fuse
烧录者：ST

**用户密钥**
烧录位置：fuse
烧录者：用户
加密者：设备唯一公钥

**用户启动镜像包**
结构：常量（镜像解密密钥密文）+用户启动固件镜像密文+（用户公钥？+签名？）

常量（镜像解密密钥密文）（对称加密）
加密者：固件加密密钥（用户密钥）

用户启动固件镜像密文（对称加密）
加密者：镜像解密密钥

签名？
镜像包完整内容计算哈希，用户私钥签名

## 3.4 时间隔离

通过硬件机制确保**启动阶段靠前的秘密（Secrets）无法被后续阶段的代码访问**。

### 1. Arm PSA 的时间隔离原则

- **各司其职**：每个启动阶段（Stage）执行完任务后必须终止，并移交给下一阶段。
- **状态传递**：必须将必要的结果和数据传递给下一阶段。
- **秘密清除**：**关键点**。前一阶段的私有数据（特别是密钥）对于后续阶段必须是**不可见**的。

### 2. STM32N6x7xx 的硬件实现机制

STM32 通过 **HDPL (Hierarchical Data Protection Level)** 机制来实现这种单向的时间流控制。

### 4.3.10 BSEC 中的时间隔离

为了强制执行启动阶段之间的隔离，每个启动级别中运行的应用程序必须在进入启动链的下一级代码之前，隐藏其之前使用的机密信息。这种保护必须保持到下一次启动序列。

定义了四个启动级别及其对应的隐藏保护级别 (HDPL)：

- **级别 0 (HDPL0)** 对应于硬件状态机或 ROM 代码执行。
- **级别 1 (HDPL1)** 对应于 STMicroelectronics 签名代码或 ROM 代码的执行。此代码是安全启动的第一阶段。
- **级别 2 (HDPL2)** 对应于存储在嵌入式 SRAM 中的 OEM 签名代码的执行。此代码是安全启动的第二阶段。
- **级别 3 (HDPL3)** 对应于应用程序运行时。

- **硬件计数器 (`BSEC_HDPLSR`)**：
  - 这是一个 **2-bit 单调递增计数器**。
  - 系统复位时重置。
  - **只增不减**（不回绕），只能由安全特权软件增加。
  - 这意味着一旦进入 Level 1，就永远无法通过软件手段退回到 Level 0。

### 3. 密钥派生与保护 (SAES & BSEC)

硬件通过将密钥生成与 HDPL 绑定，从物理底层强制执行隔离：

- **SAES (Secure AES Engine)**：
  - **派生逻辑**：使用 **HUK (Hardware Unique Key)** 和当前的 **HDPL** 值来派生 **DHUK**。
  - **不可逆性**：一旦 HDPL 计数器增加（例如从 0 变 1），SAES 硬件就无法再生成 HDPL=0 时的旧密钥。
  - **预配置能力**：SAES 允许使用比当前更高的 HDPL 值来提前生成下一阶段所需的密钥（Provisioning），但绝不允许生成低级密钥。
- **BSEC (Boot and Security Control)**：
  - 使用 **Sticky Locks** (粘性锁) 和 **Sticky Programming Locks**。
  - 一旦锁上，直到下次复位前都无法解锁，确保 Boot ROM 的 fuse secrets 在后续阶段无法被读取或篡改。

## 3.5 资源隔离

在 STM32N6x7xx 中，运行时软件隔离基于 TrustZone。 每个存储器地址被定义为存在于安全世界或非安全世界中。某些 CPU 资源（例如堆栈指针寄存器、MPU 寄存器、中断向量表或定时器）在两个世界之间是物理分组（physically banked）的。当 CPU 执行安全代码（即从安全世界地址获取的代码）时，它使用这些资源的安全世界版本。当 CPU 执行非安全代码（即从非安全世界地址获取的代码）时，它使用这些资源的非安全世界版本。 然而，在大多数情况下，安全代码和非安全代码使用相同的 CPU 硬件。

### 3.5.1 使用 IDAU/SAU 的 TrustZone 过滤

起始于偶数地址 0x00000000、0x20000000 和 0x40000000 的 256-Mbyte 地址范围，分别物理映射（aliased）到起始于奇数地址 0x10000000、0x30000000 和 0x50000000 的范围。 其目的是让安全世界通过奇数别名访问资源，而非安全世界通过偶数别名访问资源。

地址的安全性（按安全性降序排列为：S 代表安全，NSC 代表非安全可调用，NS 代表非安全）由器件 IDAU（实现定义的属性单元）和 SAU（安全属性单元）决定。这两个单元分别为每个地址提议一个安全级别，最终级别取两者提议中的较高者。被确定为 S 或 NSC 的地址访问将在标记为安全的总线上传输，而被确定为 NS 的访问将在标记为非安全的总线上传输。

安全操作系统最多可以定义 8 个 SAU 区域，每个区域都可以配置为 NS 或 NSC。任何落在已定义 SAU 区域之外的地址均保持为安全状态，因此，在复位时，SAU 单方面判定整个存储器为安全状态。

SAU 通常被配置为在偶数地址别名中为非安全代码、数据和外设开放 NS 区域。从 0x10000000 到 0x1FFFFFFF 的位置（包含 SG 指令）必须被显式 SAU 区域覆盖并配置为 NSC。

IDAU 对每个地址安全性的判定是硬连线固定的。

表 4 显示了别名目标和 IDAU 安全分配。如果 SAU 配置合理，IDAU 通常是不相关的。IDAU 的唯一潜在作用是防止任何通过 SAU 试图将上述三个“奇数” NSC 区域降级为非安全区域的尝试。

安全软件配置物理资源（在表 4 列出的范围内的别名）前端的防火墙，以确定访问目标驻留在哪个世界。这将阻止带有不匹配安全属性的访问。非安全代码无法访问驻留在安全世界中的目标（由防火墙指定）。这些目标随后专供安全世界使用。

外部存储器映射在 0x60000000 及以上的地址（无别名）。 SAU 可以配置为将这些存储器的一部分分配给非安全世界。这些存储器前端有 RISAF 防火墙，可以配置为镜像 SAU 设置，并确保 DMA 受到与 CPU 代码相同的限制。

### 3.5.2 特权操作系统控制的隔离

Cortex-M55 MPU（存储器保护单元）有助于在特权操作系统及其调度的用户进程之间进行隔离。

MPU 在安全世界和非安全世界之间是分组（banked）的，如下所示： • 安全世界对 MPU 寄存器的访问会更新 MPU_S 中的物理寄存器，该寄存器过滤从 SAU 发出的标记为安全的访问。 • 非安全世界对 MPU 寄存器的访问会更新 MPU_NS 中的物理寄存器，该寄存器过滤从 SAU 发出的标记为非安全的访问。

对于每个世界，定义了 16 个非重叠区域的属性以及剩余的背景区域。MPU 阻止用户代码访问标记为特权的区域。

如果 MPU 配置将某个存储区域指定为 Normal（普通），则 Cortex-55 在 AXI 总线上发起的所有事务都会显示为特权（即使源自用户进程）。只有 MPU 能阻止 CPU 用户进程访问 SRAM 和外部 Flash 存储器中的特权普通数据。

当从一个用户进程切换到另一个时，OS 可以重新编程 MPU 和外设防火墙，以确保每个进程只能访问自己的数据。用户应用程序可能需要使用具有 AXI 发起器的外设，该外设在用户被取消调度后仍在后台运行。为避免外设被修改后的 MPU 规则阻止，用户进程必须请求 OS 将外设配置为代表用户在特权模式下运行。OS 负责对请求的操作进行完整性检查。AXI 总线上的 HPDMA 是个特例（参见第 3.5.4 节）。

Cortex-M55 PAHBCR 寄存器必须使能 P-AHB，并配置为允许访问 P-AHB 总线上的外设区域。MPU 必须配置为将外设区域设为不可执行（execute-never）的设备存储器。对 P-AHB 上外设的访问携带正确的特权级别：为了节省 MPU 区域，可将 MPU 配置为整个外设区域用户可访问，并依赖下游 RISUP 过滤来限制某些外设仅受 OS 控制。

Cortex-M55 引入了 PXN（特权不可执行）区域属性，以防止 OS 被欺骗跳转到用户代码。

### 3.5.3 RIF 基础设施

借助总线中的硬件机制，安全 OS 确保资源和数据仅对在适当世界和适当特权级别下运行的代理可用。该基础设施称为 RIF（资源隔离框架）。

RIF 由五个组件组成： • **RIMU**：放置在 AXI 总线发起器上，用于确定附加到访问的属性。 • **RISUP**：放置在外设总线目标前端的防火墙，用于确定允许访问该外设的安全和特权级别。 • **RIFSC**：集中块，包含控制所有 RIMU 和 RISUP 的配置寄存器，并确定其他通用 RIF 参数。 • **RISAF**：放置在每个存储器目标前端的防火墙，具有独立的（本地）配置寄存器。 • **IAC（中断访问控制器）**：记录来自设备周围所有防火墙的所有安全违规事件，以便向 CPU 呈现单个中断。

某些外设具有内置防火墙，在外设内部进行本地配置。这些外设称为 RIF 感知（RIF-aware）外设。

IAC 有 256 个中断源空间，每个对应从 0 到 255 的 IAC 索引。来自 RISUP 的中断占据前 128 个索引的大部分。来自 RIF 感知外设和 RISAF 的中断占据 128 之后的索引。RISUP 和 IAC 索引是对齐的。与 IAC 索引 32x + y 关联的 RISUP 通过设置 `RISC_SECCFGx[y]` 编程为安全。通过设置 `RISC_PRIVCFGx[y]` 编程为特权。

对于所有 RIF 防火墙，资源的安全性设置只能通过安全特权访问进行配置：安全 OS 可以将 RISAF 基础区域分配给非安全 OS。非安全 OS 确定基础区域内子区域的位置、特权和可读性。

如果资源设置为安全，则对该资源的非安全访问被阻止。如果资源设置为非安全，则对存储器的安全访问被阻止（对外设无限制）。

对于所有 RIF 防火墙，资源的特权设置只能通过特权访问进行配置：如果资源已配置为安全，访问也必须是安全的。如果资源设置为特权，则仅允许特权访问（如果设置为非特权则无限制）。

默认情况下，外设防火墙的复位条件是非安全非特权，存储器是安全特权。无论如何，Cortex-55 在安全模式下启动：安全软件可以立即建立安全制度。

当检测到违规时，RISAF 会在本地记录违规访问的属性，并设置输出错误信号：其上升沿被 IAC 捕获，随后可中断 CPU。处理程序必须先清除 IAC 中的关联标志，然后清除 RISAF 中记录的错误条件。

非法访问仅在指令获取（instruction fetch）时才会生成总线错误。

## 3.9 受控调试（Access Controlled Debug）

### 上电读取生命周期

系统上电后（无视复位状态），读取 fuse 确定设备状态

- **BSEC-Open (开放态)**：无保护。调试器可以直接连接。
- **BSEC-Closed (封闭态)**：默认安全状态。调试接口被锁定，需要通过认证流程才能开启。

### 配置调试访问寄存器

对于 BSEC-closed 的器件，配置`BSEC_DBGCR` 和 `BSEC_AP_UNLOCK` 内容。只能在 Boot ROM 完成后由安全特权代码写入一次。
`BSEC_DBGCR` 仅在上电时复位：它在热复位（warm resets）期间保持其值。调试器无需在系统复位时重复认证过程。

### 调试开启背景条件

#### 调试解锁寄存器配置

`BSEC_DBGCR`中的`DBG_UNLOCK` 位写入 `0xB4`
`BSEC_AP_UNLOCK` 中的`UNLOCK`位写入 `0xB4`
`BSEC_DBGCR`中的`DBG_AUTH_SEC`位决定调试为安全与否。

#### HDPL 级别

HDPL != 0：Boot ROM 阶段绝对禁止打开调试（防止提取 Boot ROM 秘密）。
HDPL >= `DBG_AUTH_TIL`：当前层级必须达到设定阈值。`

### 调试认证流程

可信根可以执行调试认证协议开启调试。协议基于非对称加密的质询-响应 (Challenge-Response)机制（随机令牌可以阻止重放攻击）。主机与设备通过 DBGMCU 邮箱 (Mailbox) 进行双向通信 (基于 JTAG/SWD)。

1. **请求**：器件上电时，主机在设备处于复位状时，发送“开启请求 (Open-Request)”。
2. **质询**：设备生成一个**随机 Token** (Challenge)，发送给主机。
3. **响应**：主机使用私钥对“Token + 调试证书”进行签名，发回设备。
4. **验证**：设备使用预置在 fuse 的 **OEM 公钥** 验证签名。
5. **授权**：验证通过后，证书内容决定了开启的调试是否为安全。

## 4 启动和安全控制 (BSEC)

### 4.1 简介

启动和安全控制 (BSEC) 外设管理对嵌入式一次性可编程 (OTP) 熔丝阵列的访问。这些熔丝用于存储片上非易失性数据，如启动和安全参数。

嵌入式非易失性机密信息存储在 BSEC 上部区域，该区域仅在 BSEC 处于 BSEC-closed（关闭）状态时才可访问。当 BSEC 状态为 BSEC-open（开放）时，这些非易失性机密信息将被永久隐藏。

### 4.2 BSEC 主要特性

- APB 外设，仅可通过 32 位字访问。
- 12 Kbits 的 OTP（有效容量）
  - 4096 个下部 OTP 位，可按位 (1-bit) 编程
  - 4096 个中部 OTP 位，可批量 (32-bit) 编程
  - 4096 个上部 OTP 位，可批量 (32-bit) 编程，仅当 BSEC 处于 BSEC-closed 状态时可访问。
- OTP 熔丝的读取和编程，具有详细的状态报告
- 预定义熔丝字的寄存器触发器影子映射 (Shadowing)，在 BSEC 冷复位和热复位时加载。影子熔丝寄存器是可写的，除非被写锁定直到下一次 BSEC 冷复位或热复位。
- 锁定 OTP 字编程，永久锁定或锁定直到下一次 BSEC 冷复位和热复位。可选择全局编程锁定直到下一次 BSEC 冷复位和热复位。
- 锁定熔丝字的读取（字粒度），直到下一次 BSEC 冷复位或热复位
  - 锁定的影子字无法从熔丝阵列重新加载（固定值）
  - 锁定的非影子字读数为 0。
- 设备生命周期管理。
  - 当 STMicroelectronics 工程模式启用（BSEC-open 状态）时，上部熔丝字（包括 RHUK）读数为 0。
  - 可以使用 128 位密码（四次尝试机会）进入 BSEC open 状态。
  - 非易失性密钥存储撤销计数器 (epoch)。
- 四个 32 位暂存寄存器，用于存储在设备热重启期间持久存在的值。
- IN 和 OUT 32 位寄存器，用于通过 JTAG 与外部代理通信信息。
- 单调隐藏保护级别计数器，允许密钥的时间隔离和调试能力。
- 支持 TrustZone® 和 STM32 资源隔离框架 (RIF)。
- 随机生成的 256 位根硬件唯一密钥 (RHUK) 的非易失性存储，直接传递给 SAES 外设。任何软件都无法读取此密钥，并且可以将其清零直到下一次 BSEC 冷复位或热复位。

---

| **BSEC 状态 (1)**       | **上部熔丝** | **SAES 中的 DHUK (2)** | **完全调试** | **BootROM 访问** | **熔丝编程** |
| ----------------------- | ------------ | ---------------------- | ------------ | ---------------- | ------------ |
| **BSEC-open** (开放)    | 不可访问 (3) | 不可使用               | 是 (4)       | 部分             | 启用         |
| **BSEC-closed** (关闭)  | 可访问       | 硬件唯一               | 否 (5)       | 完全 (6)         | 启用         |
| **BSEC-invalid** (无效) | 不可访问 (3) | 不可使用               | 否           | 部分             | 禁用         |

**表格注释：**

1. 定义于 `BSEC_SR` 寄存器的 `NVSTATE` 位域 (`0x16`: BSEC-open, `0x0D`: BSEC-closed)。
2. SAES 外设中的派生硬件唯一密钥使用来自 BSEC 的 RHUK 信息（参见 4.3.15 节）。
3. 无法通过任何手段（功能性或非功能性）读取或编程。
4. ST 工程模式也可用。
5. 信任根应用程序可以解锁调试功能，除非 WORD18 中的任何 `debug_lock` 位 (25/24/23/22) 已被烧录。如果熔丝字 124 的第 20 位被烧录，ST 工程模式将被硬件禁用。
6. Boot ROM 执行结束时，会向 `BSEC_UNMAPR` 写入 `0xB9D8 FF1F`，将 Boot ROM 访问权限恢复为部分访问。

BSEC Closing -> BSEC Opening
通过烧录某些位，并执行复位

BSEC Opening -> BSEC Closing
用户通过 JTAG 输入已编程的 128 位密码，并执行复位

BSEC-invalid
当状态既不是 BSEC-open 也不是 BSEC-closed（`NVSTATE` 不等于 `0x16` 或 `0x0D`）时，安全状态被视为无效，此时应用最保守的安全配置

熔丝分组

| **OTP 区域**      | **大小** | **编程方式** | 用途与特性                                                                     |
| ----------------- | -------- | ------------ | ------------------------------------------------------------------------------ |
| **下部 (Lower)**  | 4K       | 1-bit        | 存储非机密信息。可在产品生命周期内进行按位更新。                               |
| **中部 (Middle)** | 4K       | 32-bit       | 存储非机密信息。一次性写入，不可更改。                                         |
| **上部 (Upper)**  | 4K       | 32-bit       | 存储机密信息（如对称密钥、私钥）。在 BSEC-open（开放）状态下被隐藏，不可访问。 |

1. 受限访问：仅在 _BSEC-closed_ 状态下可访问。用于存储非易失性机密信息。

影子寄存器映射

每个熔丝的 Word，根据对应的`BSEC_SFSRx` 寄存器中的标志位开启或关闭影子寄存器映射功能。

- 影子映射 (Shadowed)：在冷复位或热复位时，熔丝内容会自动加载到触发器（Flops）中。利于软件快速读取。
- 非影子映射 (Unshadowed)：复位时不会读取熔丝内容，也不会存储在触发器中。每次需要使用时，必须从熔丝存储器中重新加载。

## 6 资源隔离框架安全控制器 (RIFSC)

### 6.1 简介

资源隔离框架 (RIF) 是一组硬件模块，旨在强制执行和管理 STM32 硬件资源（如存储器和外设）的隔离。某些资源（例如 GP/HPDMA）在内部管理其自身的安全配置（它们是本地配置的）。此类资源被称为 **“RIF 感知型 (RIF-aware)”**。大多数资源是 **“非 RIF 感知型 (non-RIF-aware)”** 的。RIFSC 负责集中管理这些非 RIF 感知型资源的安全配置。

### 6.2 RIFSC 主要特性

- **RISC 寄存器**：与 **RISUP 逻辑**（外设资源隔离从单元）相关联。RISUP 逻辑位于非 RIF 感知型外设的配置端口前端，同时也与 RCC（复位与时钟控制）外设时钟控制逻辑相关联，用于指定外设访问和外设时钟控制的安全与特权级别。
- **RIMC 寄存器**：与 **RIMU 逻辑**（资源隔离主单元）相关联。用于指定非 RIF 感知型总线主设备 (Bus Masters) 在发起 AXI 交易时，驱动到系统总线上的安全、特权和隔离舱 (CID) 信息。
- **安全卫士 (Secure guard)**：当某个 AXI 总线主设备的关联配置端口被编程为“非安全”时，该主设备端口将被强制为“非安全”。
- 支持特殊的**调试域 (debug domain)**，赋予调试器更高的访问权限。

### 6.3 RIFSC 功能描述

6.3.1 RIFSC 复位与时钟

RIFSC 拥有单一的复位信号。在系统复位后，所有非 RIF 感知型外设均变为非安全 (non-secure) 且 非特权 (unprivileged) 状态，并且可被任何 CID 访问。

6.3.2 RISUP (外设资源隔离从单元)

RISUP 模块实例化于非 RIF 感知型外设的 AHB 配置端口 前端，用于过滤配置访问。

每个非 RIF 感知型外设都被分配了一个唯一的 **“RISUP 索引” $p < 128$**。每当位于外设 $p$ 前端的 RISUP 拦截了一次非法访问，它就会向 **IAC** 发送一个“非法访问事件”脉冲。IAC 将此事件记录在相关 `IAC_ISRx` 寄存器的 `IAFp` 位中。因此，RISUP 索引与 IAC 索引是一一对应的。

对于 $x < 4$ 且 $i < 32$，过滤逻辑确定如下：

- 如果 `RIFSC_RISC_SECCFGx[i] = 1`，则针对外设 $p = i + 32x$ 的**非安全访问将被拦截**。同时，**非安全世界**尝试编程 RCC 寄存器以关闭外设 $p$ 的时钟（或复位该外设）的操作也将被拦截。
- 如果 `RIFSC_RISC_PRIVCFGRx[i] = 1`，则**用户 (User/Unprivileged)** 对外设 $p = i + 32x$ 的访问将被拦截。同时，用户进程尝试编程 RCC 寄存器以关闭外设 $p$ 的时钟（或复位该外设）的操作也将被拦截。

每当 RCC 检测到试图关闭某外设时钟（或复位某外设）的非法尝试时，它会向 **IAC (非法访问控制器)** 发送一个事件脉冲（该事件记录在相关 `IAC_ISRx` 寄存器的 `IAF136` 位中）。

> 此处不会记录具体是哪一个外设成为了此次非法尝试的目标。
> 表 20 列出了每个非 RIF 感知型外设的 RISUP 索引。

#### 6.3.3 RIF-aware 外设与 RAM 的 RCC 安全设置

表 21 展示了如何利用 RIFSC 为 RIF-aware 外设和 RAM（即前方未放置 RISUP 的资源）配置复位或时钟门控的安全及特权访问权限。与上文提到的所有带有 RISUP 的非 RIF-aware 外设一样，下述寄存器的输出也连接到了 RCC。

**注意：** 对于 RIF-aware 外设，**可信域软件 (trusted domain software)** 有责任确保对外设时钟和复位控制的安全配置，与该外设**内部**的安全配置保持一致。

#### 6.3.4 RIMU

对于非 RIF-aware 的 AXI 总线主机外设，其发起访问的安全属性（CID、安全、特权）可在 `RIMC_ATTRx` 寄存器中配置，其中 x 是该外设的“RIMU 索引”。表 22 给出了每个 AXI 总线主机外设的索引，以及保护该外设配置端口的相关 RISUP 的索引。如果允许非安全域软件配置该外设，则 `RIMU_ATTRx[MSEC]` 的设置将被忽略，且该外设发起的所有 AXI 访问也都将被强制为非安全属性。这种覆盖机制被称为“安全守卫 (secure guard)”。

设备复位后，必须由安全特权软件对 RIMC 寄存器进行初始化。可选地，该软件可以置位 `RIMC_CR` 中的 `GLOCK` 位，从而禁止对所有 RIMC 寄存器的后续写入。该位只能通过上电复位 (power-on reset) 清除。

`RISC_RIMC_CR` 寄存器包含一个 `DAPCID` 字段，该字段给出了调试器 (DAP) 访问 AXI 总线时所使用的 CID 值。该寄存器的复位值为 0x7。无论配置如何，所有 RISAF 均将 0x7 视为合法的 CID 值。安全特权主机可以重新编程 `DAPCID`，以允许 DAP 模拟另一个分区（例如，用于调试安全配置）。

## 7. 用于地址空间保护的资源隔离从单元(RISAF)

### 7.1 RISAF 简介

RIF（资源隔离框架）是一套综合的硬件模块，旨在强制执行和管理 STM32 硬件资源（如内存和外设）的隔离。

通过 RISAF 寄存器，安全特权软件（或被委托进行配置的应用程序）可以将内存区域 (regions) 和子区域 (subregions) 分配给一个或多个安全域（安全、特权、分区）。

### 7.2 RISAF 主要特性

- 将可变大小的地址空间区域和子区域分配给安全域。
- 配置内存区域的属性：
  - 限制归属于一个或多个硬件分区 (compartments)
  - 仅安全 (Secure-only) 或 仅非安全 (nonsecure-only)
  - 仅特权 (Privileged-only) 或 特权/非特权 (privileged/unprivileged)
  - 只读、只写或读/写
- 安全特权软件可以将（区域内的）子区域的配置和定位**委托**给另一个安全域。
- 安全特权软件可以将（非安全区域内的）子区域的配置和定位**委托**给非安全特权软件。

### 7.3 RISAF 实现

下表描述了可用 RISAF 的特性，包括水印（watermark）编程详情（如粒度和受保护的地址空间）。

**RISAF4/5/6** 用于划分 **2-Mbyte 的 NPU RAM**。该内存由 **4 个 RAM Cut** 实现，每个 Cut 拥有独立的 AXI 目标端口，但采用了 **交织（interleaved/re-mapped）编址方案**。为了保持软件对内存地址的常规视图，保护这些 RAM 的 RISAF 被放置在 **NPU 互连矩阵的三个入口端口**上。用户必须在三个 RISAF 中的每一个都编程 **完全相同** 的分区配置。这些 RISAF 配备了两个额外的区域（Region），安全特权软件必须将其配置为对 NPU RAM 之外的所有访问保持 **透明（许可）**。

如表 24 中的 CID 管理列所述，**AHB 总线不携带 CID 信息**（固定为 0）。AHB 总线上的 RISAF 仅根据安全和特权状态进行读或写过滤（分别使用 `RDENC0` 或 `WRENC0` 位）。所有访问实际上都被假定为由 CPU 发起。当安全特权应用将非安全基址区域中的子区域访问控制配置权委派给非安全世界时，必须设置 `DCEN`，且针对该特定基址区域的 `DCCID` 和 `SRCID` 必须保持为 0。

如表 24 总结，**AXI 总线确实携带 CID 信息**。所有通过 AHB 配置接口对 AXI RISAF 寄存器的访问都被假定源自 **CID1**。当安全特权应用将非安全基址区域内的子区域访问控制配置权委派给非安全世界时，必须设置 `DCEN`，且 `DCCID` 必须等于 **0x1**。

**CACHEAXI** 的 AHB 配置端口受一个小型 RISAF 保护，该 RISAF 仅提供两个基址区域。按预期，这两个区域应配置为覆盖缓存失效（Cache Invalidation）控制寄存器两侧的寄存器地址空间。通过这种方式，缓存失效操作可以被保留为**仅供安全特权软件使用**，因为相关的控制寄存器被保留在了默认的 Region 0 中。

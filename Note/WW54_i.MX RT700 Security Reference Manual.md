### 第 2 章 安全概述

#### 2.1 非声明事项 (Non-claims)

随着系统安全要求和攻击面的演变，客户必须了解 NXP 不声明保护或不强力缓解的攻击类型（特别是高级物理攻击），以便客户在必要时在系统层面采取适当的缓解措施。

- 本芯片具有内置的安全事件检测功能。然而，NXP 不保证能够防御高级篡改尝试，包括在定义的规格限制之外操作设备。NXP 不保证防御半侵入式和侵入式攻击。
- 本芯片具有多项应对侧信道攻击的内置功能。然而，NXP 并不声明其完全具有抗性。这些功能的有效性尚未经过独立评估。因此，NXP 不保证结果能满足特定的客户要求。
- 本芯片的安全信任架构依赖于加密算法和数字签名的强度。如果随后确定这些算法或签名存在固有缺陷，则必须评估每个缺陷的影响，在这种情况下，NXP 不保证底层信任架构的声明。
- 本芯片具有一些内置的访问控制机制，以支持执行代码的逻辑隔离。然而，NXP 不保证设备本身能完全确保逻辑隔离。在可信执行环境（TEE）或虚拟机管理程序（Hypervisor）软件中发现的任何漏洞都可能影响这种隔离和数据完整性，并可能需要额外的缓解措施。
  NXP 建议客户根据定义的威胁模型实施适当的设计和操作保护措施，以最大程度地降低与其应用和产品相关的安全风险。

#### 2.2 概述

本章概述了设备利用以下片上组件实现的平台安全功能。

- **ELS 安全子系统**：提供密钥隔离。它还包括随机数生成功能。
- **物理不可复制函数 (PUF) SRAM 控制器 - PUF**
- **PUF 子系统**：安全地存储配置到 ELS 密钥库的应用密钥。
- **公钥加密加速器 (PKC) - PKC**
- **代码看门狗 (CDOG)**：通过检测代码执行流中的意外变化来确保软件完整性。
- **入侵与篡改响应控制器 (ITRC)**：用于配置对片上安全传感器检测到的入侵事件的响应动作。
- **安全通用接口 (SAFO-SGI)**：支持 SAFO-SGI 算法。
- **安全 AHB 总线和 AHB 控制器 (AHBSC)**：支持系统层面的安全可信执行。
- **XSPI**：支持联机 Prince 加解密 (IPED)，根据实例不同，支持 CTR/GCM 或 CTR/GCM/XEX 工作模式。
- **真随机数生成器 (TRNG)**：一种生成熵的硬件加速器模块。
- **数字和模拟毛刺检测 (GDET)**：提供电源毛刺检测。

#### 2.3 信任根 (Root of Trust, RoT)

信任根（RoT）由真正不可变的硬件逻辑组成，包括模拟和数字逻辑、只读存储器（ROM）以及一次性可编程存储器（OTP）。不可变 RoT 是保证任何安全功能（包括安全启动、安全调试、生命周期管理等）的基础。在该设备中，不可变 RoT 嵌入在引导 ROM（不可变引导加载程序）中。它利用设备的硬件加密功能来实现其功能。

#### 2.4 生命周期管理

在整个生命周期中，典型设备会经历全球不同的地点。它在半导体工厂制造，在芯片制造商设施中进行测试和封装，售卖给各类经销商，再进一步卖给原始设备制造商（OEM），由其代工厂（CM）进行组装、测试和预置（Provisioning），最后交付给终端客户。在发生故障的情况下，设备会返回给 OEM 甚至返回给芯片制造商进行进一步的故障分析。

设备生命周期状态用于反映设备的实际状态，进而指示设备在特定时间内应如何精确保护其承载的资产。例如，当设备在芯片制造商设施中进行测试，且尚未预置 OEM 或终端客户资产时，其在调试或测试方面的访问限制，要比设备交付到终端客户手中时更少。

生命周期状态是单向（Monotonic）的，意味着它只能增加。不同生命周期状态之间的转换是一个不可逆的过程。不可变 RoT 负责生命周期管理，并相应地执行设备访问策略。

#### 2.5 安全启动

安全启动确保设备引导加载程序、固件和其他软件在启动过程中的真实性、完整性和机密性，并确保达到预期的安全生命周期状态。ECDSA P-256 配合 SHA-256 或 ECDSA P-384 配合 SHA-384 用于保证固件镜像的真实性和完整性。不可变 RoT 负责执行安全启动，并根据生命周期状态定义的策略进行操作。

ROM 实现了以下安全启动特性：

- 使用基于 NIST P-256 和 P-384 曲线计算的镜像进行 ECDSA 签名验证。
- 固件版本的防回滚（Anti-rollback）检查。
- 支持从连接到 xSPI0 的 Octal/Quad/Dual/Single bit Flash 或 Hyper-Flash 进行就地执行（XIP）启动。
- 使用 SB3.1 格式从以下接口进行加载至 RAM（Load-to-RAM）并执行启动：
  — 连接到 xSPI0 的 Octal/Quad/Dual/Single bit Flash 或 Hyper-Flash
  — eMMC 存储设备
  — eSD/SD/SDHC 卡存储设备
  — 串行接口：UART、运行频率高达 50MHz 的 SPI 从机（Slave）、USB、I2C
- xSPI0 接口支持双镜像（Dual-image）启动。
- eMMC 和 SD 存储设备支持双镜像启动。第二个镜像的偏移量由客户在 OTP 中配置。
- 使用 SB3.1 文件格式通过以下接口进行恢复启动（Recovery boot）：
  — 连接到由客户在 OTP 中定义的 FlexComm 的 1-bit SPI-flash
  — UART、SPI 从机、USB、I2C

#### 2.6 安全更新

安全更新是在现场安全更新固件镜像的过程。在本芯片上，ROM 支持使用 SB3.1 文件格式进行安全更新。SB3.1 文件使用 AES-128 或 AES-256 加密，并使用 ECDSA P-256 或 ECDSA P-384 签名。

安全更新提供新镜像的真实性和机密性，还可以包含镜像回滚保护。当运行的固件受到威胁或需要添加新功能时，需要进行固件更新。运行中的固件负责使用 ROM API 接收并验证新固件镜像。随后的安全启动将再次验证新固件镜像，确保不可变 RoT 仍负责确保存储最新固件的真实性。

#### 2.7 安全调试

安全调试是根据生命周期状态定义的策略安全访问调试接口的过程。当调试器想要调试设备时，调试器通过调试信箱（Debug Mailbox）发出信号并启动复位。在启动期间，设备检查调试信箱并启动完整的基于异步密钥加密的质询-响应（Challenge-Response）协议。设备发出 256 位随机质询，并由调试器签名。随后设备验证响应，如果成功，则允许调试。不可变 RoT 负责整个过程。详情请参见“调试信箱”章节。

#### 2.8 IP 保护

IP 保护是一系列用于保护存储在设备上的重要代码和数据机密性与完整性的机制。基于 PRINCE 的存储加密可用于为存储在外部 Flash 中的代码/数据提供机密性。XSPI0 和 XSPI1 最多支持 16 个独立的内存区域/上下文。

#### 2.9 安全隔离

芯片具有多个功能域和电源域，总线架构根据目标应用进行划分，以平衡性能和功耗效率。芯片使用以下组件提供安全隔离：

- **ELS**：带有专用处理引擎（RISC-V 核心）和加密加速器，提供完全隔离的安全功能。
- Arm TrustZone：为 Armv8-M 架构提供额外隔离。
  — Cortex-M33 核心内部的存储保护单元（MPU）。CPU0 和 CPU1 各有 8 个 MPU 区域。
  — Cortex-M33 核心内部的安全属性单元（SAU）。CPU0 和 CPU1 各有 8 个 SAU 区域。
- 安全 AHB 总线控制器 (AHBSC)：提供寄存器来定义哪些域可以访问公共域和感知域中的共享 SRAM 及外设。
  — 内存仲裁控制 (MAC)：作为内存仲裁器的一部分，提供按域划分的共享 SRAM 访问限制。
  — 外设仲裁控制 (PAC)：作为外设桥仲裁器的一部分，提供按域划分的共享外设访问限制。

#### 2.10 安全证明 (Secure Attestation)

安全证明是一系列机制，用于向远程方提供关于设备真实身份、软件和固件版本以及完整性和生命周期状态的证据。由可信计算组（TCG）定义的设备身份组合引擎 (DICE) 在启动期间使用不可变 RoT 创建唯一的设备身份，该身份综合考虑了设备唯一机密（UDS）、设备的硬件状态及其固件。运行时指纹 (RTF) 是 NXP 专有的证明机制，它在启动时和运行时测量设备状态。

#### 2.11 安全存储

本芯片支持 ELS 密钥库及以下两种密钥分级结构：

- 基于 SRAM-PUF 生成的设备唯一密钥 (DUK)
- 基于 OTP 的 DUK

基于 SRAM-PUF 生成的 DUK 仅在外部非易失性存储器可用时受支持。

> **注意**：安全密钥存储需要设备唯一根密钥 (DUK)，它作为信任根进一步保护应用密钥。从 PUF 获取 DUK 是非常理想的，但 SRAM-PUF 需要约 1000 字节的激活码存储空间，而片上没有此空间。因此，这种基于 PUF 的 DUK 仅在具有片外非易失性存储的终端系统中使用。为了支持在 PUF 注册前需要 DUK 的安全存储用例，本芯片提出了基于 OTP 的 DUK。

在基于 OTP 的 DUK 分级结构中，设备唯一密钥 (DUK) 在 ELS 中派生。该密钥随后用于派生存储加密 (PRINCE) 密钥。

#### 2.12 信任部署 (Trust Provisioning)

信任部署是用于创建初始设备身份密钥的过程。其主要目标是提供设备来源的加密证明，并为 OEM 提供一套工具，以便安全地预置其自身资产。每台设备上都会创建一个设备唯一的公私钥对，其中公钥部分由 NXP 收集并签名。该签名的公钥以设备唯一证书的形式重新安装到每台设备上，作为设备来源的真实证明。相应的私钥连同其他预装密钥，随后用于身份验证和与设备的安全连接，从而实现 OEM 资产的安全预置。

#### 2.13 安全密钥管理

安全密钥管理是保护重要密钥及各种密钥材料的过程，这些材料对于维护终端用户、OEM 和 NXP 资产的安全至关重要。该过程强烈依赖于由 ELS 密钥库、硬件逻辑和 ROM 组成的不可变 RoT。系统提供一个设备唯一的根密钥（Master Key），且仅用于进一步的密钥派生。部分派生数据由不可变 RoT 提供，准确反映设备状态，确保在不同状态下派生出不同的密钥。例如，不同的生命周期状态通常会产生不同的派生密钥。同样，调试端口开启时与关闭时派生出的密钥也会不同。所有平台密钥都存储在安全子系统内，始终对应用内核隐藏。

#### 2.14 异常检测与响应

异常检测与响应描述了分析设备输入和输出（如传感器数据）以及软件完整性和应用程序运行情况以发现异常事件的过程或算法。如果需要，它会触发并执行用户定义的安全应用（例如记录异常、向云端后台发送消息、重置设备及更改生命周期状态）。

### 第 3 章 生命周期状态

#### 3.1 概述

本芯片支持安全生命周期状态模型。当前的生命周期状态决定了设备功能、调试与测试端口的可用性以及资产的可访问性。生命周期状态由 **LC_STATE** 熔丝值控制（包括两个熔丝：word 143 中的 LC_STATE 和 word 37 中的 LC_STATE_RED，需确保这两个熔丝的低 8 位值完全相同）。选择状态值时，通过烧写额外的熔丝位来推进状态。由于熔丝控制生命周期状态，因此向更高级别状态的迁移是不可逆且永久的过程。生命周期只能推进，无法返回到之前的状态。

引导 ROM 负责检查生命周期状态。根据生命周期状态，ROM 决定使用何种引导流程，包括是否将控制权交给应用程序代码。ROM 还根据生命周期状态处理测试和调试端口的开启。如果芯片处于 **Bricked（变砖）** 状态或任何无效的生命周期状态，ROM 将锁定芯片。

> 注意：
>
> 位保护 (BP)：带有 "BP" 前缀的熔丝位是一种冗余熔丝位，每当设置相应的非 BP 熔丝时，该位也会被设置。在生命周期状态熔丝中，BP 是一种冗余条目，用于更好地防御故障攻击。

#### 3.2 生命周期状态转换

下图展示了生命周期状态及其转换关系，图中 SoC 状态显示了在进入相应 LC 状态时预期进行的预置（Provisioned）或配置。

虽然可以进行额外的状态转换来推进生命周期，但下图中及后续章节中显示的转换是唯一推荐且支持的路径。

> 注意：
>
> 采用 TrustZone 技术的 Cortex-M33 在单个核心内提供安全和非安全处理域。在下图中以及本章通篇，这些处理域的调试是隔离的，安全域记为 "TZ debug"，非安全域记为 "nTZ debug"。

#### 3.3 生命周期状态

![image.png|600](https://lincx-img.oss-cn-shanghai.aliyuncs.com/img/20260104155303165.png)

下表列出了生命周期状态，并显示了每个状态下的调试/测试端口可用性和资产访问权限。更多信息请参考熔丝图（Fusemap）。

> 注意：
>
> NXP 资产仅通过 NXP 预置固件可用。

**表 6. 生命周期状态**

| **生命周期**                         | **类型**     | **LC_STATE[7:0] 熔丝** | **测试端口** | **TZ 调试端口** | **nTZ 调试端口** | **ISP 命令** | **NXP 资产**  | **OEM 资产** | **描述**                                                                                    |
| ------------------------------------ | ------------ | ---------------------- | ------------ | --------------- | ---------------- | ------------ | ------------- | ------------ | ------------------------------------------------------------------------------------------- |
| **Develop** (开发)                   | 客户         | 0000_0011              | 是           | 是              | 是               | 全部         | 受限 NXP 预置 | 可用         | 离开 NXP 生产阶段后的初始客户开发状态。                                                     |
| **Develop2** (开发 2)                | 客户         | 0000_0111              | 否           | 已认证          | 是               | 受限         | 受限 NXP 预置 | 可用         | 可选的客户开发状态。用于非安全世界 (NS) 代码的开发。                                        |
| **In-field** (现场)                  | 客户         | 0000_1111              | 否           | 已认证          | 已认证           | 受限         | 受限 NXP 预置 | 可用         | 供终端客户使用的现场应用状态。                                                              |
| **In-field Locked** (现场锁定)       | 客户         | 1100_1111              | 否           | 否              | 否               | 受限         | 受限 NXP 预置 | 可用         | 另一种现场应用状态，防止使用现场返修/故障分析 (FA) 状态。设备其余行为与 In-field 状态相同。 |
| **Field Return OEM** (OEM 现场返修)  | 现场返修     | 0001_1111              | 是           | 是              | 是               | 无           | 受限 NXP 预置 | 密钥已轮换   | 现场返修状态。                                                                              |
| **Failure analysis (FA)** (故障分析) | 现场返修     | 0111_1111              | 是           | 是              | 是               | 无           | 密钥已轮换    | 密钥已轮换   | NXP 现场返修状态 (CQC)。                                                                    |
| **Bricked** (变砖)                   | 生命周期终结 | 1111_1111              | 否           | 否              | 否               | 无           | 密钥已轮换    | 密钥已轮换   | 变砖状态，防止设备被使用。                                                                  |

#### 3.4 客户生命周期状态

以下章节描述了客户生命周期状态——Develop（开发）、Develop2（开发 2）、In-field（现场）和 In-field Locked（现场锁定）。这些状态旨在供客户常规使用，但某些状态是可选的（例如 Develop2、In-field Locked 和 Field Return OEM）。本节详细描述客户生命周期状态及所有有效的转换，但不包括向 Bricked 状态的转换（详见“生命周期终结”章节）。

##### 3.4.1 Develop 生命周期状态 (LC_STATE = 0x03)

从 NXP 交付的设备处于 Develop 生命周期状态。在此状态下，芯片的所有客户功能均可访问。此模式推荐用于早期软件开发。

在 Develop 状态下：

- 如果 **ENF_TZM_PRESET** 写入为 1，则镜像必须包含 TZM 数据。
- 测试和调试端口默认开启。
- **OCOTP 影子寄存器（Shadow Registers）** 可用于尝试不同的引导行为，而无需修改 OCOTP 实体熔丝。
- 此状态下默认禁用安全启动。ROM 根据引导镜像的类型进行检查/身份验证，如果通过则启动。可以使用 **ENF_SEC_BOOT** 字段在此状态下强制执行安全启动，之后仅允许正确签名和有效的 SB3 镜像引导。

i.MX RT700 设备允许在 Develop 状态（LC_STATE = 0x03）下，通过 OEM 预置 SB 文件在 OTP 影子寄存器中尝试 **CUST_MK_SK** 密钥。此特性允许客户在永久烧写到 OTP 存储器之前，验证 CUST_MK_SK 密钥的正确性。

CUST_MK_SK 密钥由 ROM 引导加载程序用于解密 SB3.1 文件。为了处理 SB3.1 文件，此 RFC3394 密钥块密钥需要存在于 **CUST_MK_SK_BLOB** 中。该密钥的生成和加载过程发生在设备预置期间。详见“安全信任预置”章节。

如果设备在 Develop 状态下成功处理了可加载 CUST_MK_SK 密钥的 OEM 预置 SB 文件，则该密钥块不会加载到 OTP 永久存储器的 CUST_MK_SK_BLOB 中，而是加载到 **CUST_MK_SK_BLOB 影子寄存器**中。热复位后，如果密钥正确，则可以正常处理普通 SB3.1 文件（非 OEM 预置 SB 文件）。通过这种方式，可以在提交到永久 OTP 之前验证其正确性。

> 注意：
>
> 在冷启动（POR）后，CUST_MK_SK_BLOB 影子寄存器将被清除，SB3.1 文件处理将失败。OEM 预置 SB 文件仅允许在 Develop 生命周期内处理。如果生命周期超过 Develop，该文件将失效。

有两种方法可以将 CUST_MK_SK 存储到永久 OTP 的 CUST_MK_SK_BLOB 中：

- 从 CUST_MK_SK_BLOB 影子寄存器中读取值，并使用 ISP `efuseProgramOnce` 命令或 OTP 编程 API 将其存入 OTP。
- 在加载 CUST_MK_SK 命令之前，在 OEM 预置 SB 文件中包含推进生命周期的命令。SB 文件处理成功且 LC 推进到 7h 或更高后，CUST_MK_SK 将存入 OTP，并在热复位后从 Develop 状态进入目标生命周期。

设备可以从 Develop 状态推向 Develop2、In-field、In-field Locked 或 Bricked 状态。

###### 3.4.1.1 从 Develop 转换到 Develop2 生命周期状态

设备可以从 Develop 移动到 Develop2 状态，以便在保护安全世界代码和调试的同时，允许对非安全世界（NS）代码进行调试和开发。在现场（In-field）生命周期中强制执行安全启动。

在从 Develop 转换为 Develop2 之前，必须配置以下特性：

- 安全启动 (Secure Boot)
  RoTKH 和 ENF_CNSA 是安全启动所必需的。无论是签名镜像 (XIP) 还是 SB3 镜像 (加载至 RAM 场景) 都需要这些配置。
  — 信任根密钥哈希：ROTKH[383:0] / ROTKH[255:0]
  — ENF_CNSA
  若要使用 SB3，还需要配置更多字段：
  — CUST_MK_SK_BLOB：用于启动 SB3 镜像
- TrustZone
  — TrustZone 配置可以作为安全应用代码的一部分。
  — TrustZone 预置数据可以包含在镜像的清单区域 (Manifest area) 中。

#### 3.4.1.2 从 Develop 转换到 In-field 生命周期状态

当开发完成且产品准备好部署到现场时，设备可以从 Develop 移动到 In-field 状态。在 In-field 生命周期中会强制执行安全启动。

在转换之前，必须配置以下特性：

- 安全启动
  RoTKH 和 ENF_CNSA 是安全启动所必需的。签名镜像 (XIP) 或 SB3 镜像均需要。
  — 信任根密钥哈希：ROTKH[383:0] / ROTKH[255:0]
  — ENF_CNSA
  若要使用 SB3，还需要配置：
  — CUST_MK_SK_BLOB：用于启动 SB3 镜像

#### 3.4.1.3 从 Develop 转换到 In-field Locked 生命周期状态

当开发完成、产品准备部署到现场且不需要现场返修功能时，设备可以从 Develop 移动到 In-field Locked 状态。在 In-field Locked 生命周期中会强制执行安全启动。

在转换之前，必须配置：

- 安全启动
  — ROTKH[383:0] / ROTKH[255:0]
  — ENF_CNSA
  若要使用 SB3：
  — CUST_MK_SK_BLOB

#### 3.4.2 Develop2 生命周期状态 (LC_STATE = 0x07)

Develop2 是一个可选状态，用于支持非安全 (NS) 世界代码的开发，同时为安全 (S) 世界代码提供保护。

在 Develop2 状态下：

- 测试端口和 S 世界调试端口已关闭。S 世界调试端口可以通过调试认证机制可选地开启（该机制必须在设备处于 Develop 状态时已启用）。
- NS 世界调试端口默认开启。如果编程了调试认证字段 (CC_SOCU_NS)，则根据该字段确定调试访问权限。
- 此状态强制执行安全启动。
- 主镜像负责配置 TZ-M 设置。建议使用 TrustZone 预置数据来配置 TZ 设置。
- 允许使用受限的 ISP 命令 (GetProperty, Reset, SetProperty, 和 ReceiveSbFile)。

设备可以从 Develop2 推进到 In-field 或 Bricked 状态。

##### 3.4.2.1 从 Develop2 转换到 In-field 生命周期状态

当开发完成且产品准备部署时，设备可以从 Develop2 移动到 In-field 状态。

在转换之前，必须配置以下可选特性：

- NS 世界调试认证设置
  — DCFG_CC_VU：可以选择不烧写此熔丝。如果烧写，需确保进行调试认证时 CC_UV 的值与此熔丝相同。

转换到 In-field 状态必须烧写：

- **LC_STATE**：软件必须调用 ROM 的 `otp_program` API 将 LC_STATE 熔丝设置为 `0b0000_1111`。

#### 3.4.3 In-field 生命周期状态 (LC_STATE = 0x0F)

In-field 状态是产品部署给终端客户的主要状态。

在 In-field 状态下：

- 测试和调试端口默认关闭。如果启用了调试认证，则认证过程可用于重新开启调试端口。
- 强制执行安全启动。
- TZ-M 的使用是可选的。
- 允许使用受限的 ISP 命令 (GetProperty, Reset, SetProperty, 和 ReceiveSbFile)。

设备可以从 In-field 推进到 In-field Locked, Field Return OEM, 或 Bricked 状态。

以下部分总结了处理调试限制的高级步骤：

1. 将生命周期状态编程为 In-field (LC_STATE = 0x0F)。该状态确保测试和调试端口默认关闭。
2. 用户可以选择使用“禁用额外调试功能”章节中提到的熔丝位，来禁用各核心 (CPU0, CPU1, HiFi4) 的额外调试能力。
3. 对于 In-field 状态，只要步骤 2 中的熔丝未烧写，用户就可以通过调试认证过程重新开启核心的调试端口。在此状态下，允许受限的 ISP 命令。用户也可以将状态迁移至 In-field Locked (LC_STATE = 0xCF)，但此时调试端口将永久关闭且无法恢复。
4. 固件更新只能通过 ISP 命令或 IAP 命令执行。例如，在 In-field 和 In-field Locked 状态下可以执行 `ReceiveSbFile`。
5. 有特定熔丝控制进入 ISP 的方法。详情参见附件的 `IMXRT700_Fusemap.xlsx`。
6. 用户可以执行 IAP 调用 `runBootloader()`，重新进入 ISP 模式，通过指定的序列接口接收 SB3 文件以更新镜像。

| **位名称**           | **位描述**                                                                    |
| -------------------- | ----------------------------------------------------------------------------- |
| **ISP_MODE_PIN_DIS** | 禁用通过 ISP 模式引脚进行启动模式选择。<br>                                   |
| **ISP_DM_DIS**       | 禁用通过调试信箱（Debug Mailbox）命令进入 ISP 模式。                          |
| **ISP_FT_DIS**       | 禁用在启动介质中未发现有效镜像时，作为回退方案（Fall Through）进入 ISP 模式。 |
| **ISP_API_DIS**      | 禁用通过 ROM API 进入 ISP 模式。<br>                                          |

##### 3.4.3.1 从 In-field 转换到 In-field Locked 生命周期状态

如果确定不需要现场返修功能，可以将设备从 In-field 迁移到 In-field Locked 状态。

- 烧写 **LC_STATE**：调用 ROM API 将熔丝设置为 `0b1100_1111`。

##### 3.4.3.2 从 In-field 转换到 Field Return OEM 生命周期状态

如果部署在现场的设备因故障返回，可将设备移动到 Field Return OEM 状态，以禁用正常操作并重新开启设备测试。

NXP 建议的转换步骤：

1. 使用调试认证获取权限，通过调试信箱 (Debug Mailbox) 发送 `Set FA mode` 命令。
2. 发送 Set FA mode 命令。该命令调用 ROM 处理程序：

   a. 将 LC_STATE 熔丝设置为 0b0001_1111

   b. 复位设备

#### 3.4.4 In-field Locked 生命周期状态 (LC_STATE = 0xCF)

这是一个可选状态，用于不支持现场返修或故障分析的产品。其行为与 In-field 基本一致，但调试和测试端口永远无法再次开启。

- 测试和调试端口已关闭。调试认证机制无法重新开启调试端口。
- 强制执行安全启动。
- 仅能推进到 Bricked 状态。

#### 3.5 Field Return (现场返修) 状态

- **第 1 阶段**：初步调查，设备保持在 In-field 状态。利用调试认证重新开启端口获取故障信息。
- **第 2 阶段**：如果需要进一步控制，移动到 **Field Return OEM** 状态。
- **第 3 阶段**：如果怀疑是硅片结构或制造问题，在返回 NXP 之前移动到 **Failure Analysis (FA)** 状态。

##### 3.5.1 Field Return OEM 生命周期状态 (LC_STATE = 0x1F)

- 测试和调试端口开放。
- ROM 保持在 `while(1)` 循环中，不将执行权交给应用代码。调试端口可用于加载并执行诊断固件。
- 可推进到 FA 或 Bricked 状态。

##### 3.5.1.1 从 Field Return OEM 转换到 FA 生命周期状态

1. 调用 ROM API 将 LC_STATE 设置为 `0b0111_1111`。
2. 擦除系统 SRAM。
3. 擦除任何其他敏感信息。

##### 3.5.2 Failure Analysis (FA) 生命周期状态 (LC_STATE = 0x7F)

- 每次启动时，ROM 都会检查并擦除密钥存储。
- ROM 保持在 `while(1)` 循环中。必须通过调试或测试端口加载执行诊断固件。

#### 3.6 终结 (End-of-Life) 状态

##### 3.6.1 Bricked 生命周期状态 (LC_STATE = 0xFF)

- 变砖状态是设备永久退出服务的状态。在此模式下，ROM 在任何复位后立即锁定设备。调试和测试端口也被禁用。
- 这是最终状态，无法推进到其他状态。

##### 3.6.1.1 从任何状态转换到 Bricked 生命周期状态

- 烧写 **LC_STATE**：调用 ROM API 将其设置为 `0b1111_1111`。

# 第 7 章

# 安全启动

## 7.1 概述

ROM 引导加载程序（ROM boot loader）的安全部分提供以下基本操作：

- 安全启动
- 安全固件更新
- 安全相关的杂项功能

## 7.2 功能描述

### 7.2.1 安全启动

安全启动防止未经授权的代码在给定产品上执行。它通过在退出复位状态时始终让设备的 ROM 处于执行模式来实现这一安全级别。这允许 ROM 检查用户可执行映像，以确定该代码的真实性。如果代码是真实的，则控制权将转移给它。这建立了从 ROM 到用户引导代码的信任链。通过验证与附加代码层关联的数字签名，可以进一步扩展此链。

在该架构中，使用椭圆曲线数字签名算法（ECDSA）来验证引导代码的真实性。引导代码始终使用 ECDSA 私钥进行签名。用于签名验证的相应 ECDSA 公钥（根信任密钥，Root of Trust Keys）包含在签名映像中的证书块内。支持最多四个根信任密钥。根信任公钥的哈希值应在用户制造过程中预置在每个单独的设备中。

设备可以配置为在开发期间启动普通映像。在这种情况下，ROM 不检查要启动的映像，或者仅执行 CRC32 检查，具体取决于配置。

### 7.2.2 安全固件更新

如果在启用安全启动的情况下需要在现场执行固件更新，则首选安全固件更新机制。否则，非真实的固件可能会被写入设备，导致其无法启动。从最基本的意义上讲，安全固件更新仅在将新固件提交到内存之前对其进行身份验证。在这种情况下，信任链从当前的、正在执行的代码扩展到新代码。

安全固件更新的另一个用例是在通过 Web 等公共媒体传输期间隐藏应用程序二进制代码。这通过加密固件更新映像来实现。当新固件写入设备存储器时，它会被解密。如果已经配置并启用了实时 IPED 加密，固件在写入操作期间将再次被加密。

在此架构中，支持上述两种安全固件更新情况。SB 文件格式经过加密和数字签名。SB 文件可以通过 USB、UART 等接口加载，也可以作为完整的二进制文件提供给 ROM API。

#### 7.2.2.1 扩展信任链

在安全启动将 CPU 控制权转移给用户代码后，该代码可能需要加载额外的代码片段。这建立了信任链的另一个环节。当需要许多嵌套子模块时，此过程可以继续，每个父代码模块都会对链中的下一个环节进行身份验证。

NBOOT API 用于从客户代码中验证附加代码映像的签名。使用 API 验证签名使客户代码能够完全控制哪些附加代码必须签名，以及这些代码在内存中如何组织。

### 7.2.3 杂项功能

ROM 提供对各种安全相关功能的支持：

- DICE（设备标识组合引擎）
- 在 ROM 安全启动期间加载 TrustZone-M 配置
- 使用 IPED 外设模块从加密的外部 XSPI NOR 闪存启动
- 调试认证
- 设备预置（ROM 嵌入式支持引导密钥的初始安全预置）

### 7.2.4 映像身份验证流程图

ECDSA 映像身份验证流程如下图所示：

## 7.3 密钥

CUST_MK_SK 以 RFC3394 blob 的形式存储在 OTP 熔丝中，引导加载程序在处理 SB 文件期间使用它来解密并派生 SB3.1 加密密钥。CUST_MK_SK 可以在设备预置过程中通过 HSM_GEN_KEY（随机密钥）生成，也可以通过 HSM_STORE_KEY（用户定义密钥）命令预置。要将此密钥存储到 OTP 熔丝中，应使用 LOAD_KEYBLOB 命令。SB_STORE_KEY 命令获取密钥 blob，将其加载到 ELS，然后将 RFC3394 blob 形式的密钥写入 OTP。

## 7.4 熔丝中的安全启动相关配置字段

- BOOT_CFG1
- LIFECYCLE_RED
- ROTKH0..11, CUST_MK_SK0..11
- NS_FW_VER0..15
- SEC_FW_VER0..3
- IMAGE_KEY_REVOKE
- DCFG_CC_VU
- ROTK_USAGE
- LIFECYCLE
- XSPI0_IPED_CTX0..3
- XSPI1_IPED_CTX0..3

## 7.5 普通映像结构（Plain image structure）

只有在 `ENF_SEC_BOOT` OTP 熔丝未强制执行安全启动时，ROM 才支持无签名的普通 CRC 映像。这种映像类型主要用于开发生命周期阶段。

无签名 CRC 映像的结构如图 18 所示。当映像类型（Image Type）为 0x0 时，CRC32 校验会被跳过。此类映像在开发期间可作为通用映像使用。

> **注意**

## 7.6 已签名映像结构（Signed image structure）

映像使用 ECDSA P-256 或 P-384 算法进行签名。对于 ECDSA P-256 签名映像，摘要使用 SHA-256 计算；对于 ECDSA P-384 签名映像，摘要使用 SHA-384 计算。

已签名映像的结构如图 19 所示。在距离已签名映像起始位置偏移量 0x28 处，必须存放一个名为 `offsetToCertificateBlockInBytes` 的 32 位偏移量，该值是指向证书块头（certificate block header）的偏移字节数。

Flash 中的可执行代码映像通常以 NVIC 向量表开始。偏移量 0x28 处的字是向量表中的一个保留槽位。

例如，如果一个映像位于 XSPI NOR 闪存的地址 0x4000 处，其证书块头位于地址 0x8000 处，那么地址 0x4028（起始地址 0x4000 + 偏移量 0x28）处的字将包含数值 0x4000（即 0x8000 - 0x4000）。

下图展示了一个标准的 Cortex-M33 NVIC 向量表，其中突出显示了指向证书块头的偏移量。

### 7.6.1 证书块（Certificate block）

参见“证书块 v2.1”章节。

### 7.6.2 映像清单（Image manifest）

映像清单包含额外的映像数据，例如固件版本、可选的 Trust-Zone 预设数据，以及用于低功耗快速唤醒映像身份验证的映像 CRC32 值。

# 第 11 章

# 安全 AHB 总线与 AHB 控制器 (AHBSC)

## 11.1 芯片特定的安全 AHB 控制器信息

**表 201. 相关信息参考链接**

| **主题**       | **相关模块**    | **参考**                 |
| -------------- | --------------- | ------------------------ |
| 详细描述       | 安全 AHB 控制器 | 安全 AHB 控制器          |
| 系统存储器映射 | -               | 参见“系统存储器映射”章节 |
| 时钟           | -               | 参见“时钟”章节           |
| 电源管理       | -               | 参见“电源管理”章节       |
| 信号复用       | 端口控制        | 参见“信号复用”章节       |

1. 对于本表中提到的所有参考章节，请参阅 IMXRT700 参考手册。

### 11.1.1 模块实例

该设备具有三个 AHBSC 模块实例，每个实例具有四个别名基地址（aliased base addresses）。

**表 202. AHBSC 实例**

| **特性**     | **AHBSC0**                       | **AHBSC3**                                                  | **AHBSC4**                                           |
| ------------ | -------------------------------- | ----------------------------------------------------------- | ---------------------------------------------------- |
| **位置**     | VDD2_COMP                        | VDD1_SENSE                                                  | VDD2_MEDIA                                           |
| **访问权限** | CPU0, HIFI4, EZH-V, eDMA0, eDMA1 | CPU0, CPU1, HIFI4, HIFI1, EZH-V, eDMA0, eDMA1, eDMA2, eDMA3 | CPU0, CPU1, HIFI4, EZH-V, eDMA0, eDMA1, eDMA2, eDMA3 |
| **控制模块** | COMPUTE 主设备、MBUS(C)、PBUS    | SENSE 主设备、MBUS(S)                                       | MEDIA 主设备、NIC_MEDIA0、NIC_MEDIA1                 |

### 11.1.2 安全注意事项

AHBSC 模块实例化为占用四个模块槽位：AHBSC_xxx、AHBSC_xxx_ALIAS1、AHBSC_xxx_ALIAS2 和 AHBSC_xxx_ALIAS3。AHBSC 寄存器仅在执行**安全且特权（secure and privileged）**访问时才允许写入。当尝试使用任何其他访问级别进行写入时，系统将产生一个 **Hypervisor 中断**，而不是硬故障（hard fault）。但读取操作允许在任何访问级别下进行。

通过对相应访问级别的别名槽位执行写入访问，Hypervisor 中断可作为一种机制，实现从任何其他级别直接切换到安全特权级别。鉴于上述约束，实施 Hypervisor 模型的系统应使用 `AHB_SECURE_CTRL_PERIPH_RULE0` 寄存器按下文所述配置这四个别名。

### 11.1.3 GLIKEY protection

Some registers in the AHBSC memory space are protected by the GLIKEY module. See the GLIKEY chapter in this document for reference.

### 11.1.4 安全 AHB 控制器模式

安全 AHB 控制器模块支持严格模式（strict mode）。在严格模式下，禁止从安全数据访问非安全地址。以下外设——GPIO、ELS、PUF、PKC 和 AHBSC——可以自行控制访问权限。为了使这些外设在严格模式下能被安全和非安全主设备同时访问，为这些外设分配了别名槽位（alias slots）。软件可以将外设的每个槽位配置为不同的安全级别。因此，具有不同安全级别的主设备可以独立访问该外设。

## 11.2 概述

AHB 安全控制器允许为所有 MPC（存储器保护检查器）、PPC（外设保护检查器）和 MSW（主设备安全封装器）编程安全属性。AHBSC 支持锁定 CPU0 和 CPU1 的 SAU（安全归属单元）设置、安全和非安全 MPU 设置（MPU_S/MPU_NS）、以及安全和非安全向量偏移设置（VTOR_S/VTOR_NS）。这使得引导 ROM（BootROM）能够保护某些安全特性，并防止非预期或恶意地动态启用这些设置的可能性。

本章讨论了 Armv8-M TrustZone 的基础知识，然后描述了扩展 TrustZone 安全基础以实现完整可信执行环境的特性。

### 11.2.1 特性

- 带有 AXI 扩展的增强型 AHBSC
- 启用 TrustZone 支持的 Cortex-M33
- 归属单元：SAU（安全归属单元）、IDAU（设备归属单元）
- 安全 MPU、安全 NVIC、安全 SYSTICK、安全栈指针
- 安全存储器映射别名
- 支持 Arm AMBA 5.0 AHB 安全总线
- 支持 Arm AXI3 AXI 总线
- 安全总线控制器
- 存储器和外设保护检查器
- 针对 AHB 主设备的安全归属封装器
- 安全调试
- 计算域（Compute domain）：
  - SRAM 访问使能
- 感知域（Sense domain）：
  - SRAM 访问使能
  - AIPS 槽位访问使能
  - APB 外设槽位访问使能
- AHBSC 存储器空间中的某些寄存器受 GLIKEY 模块保护。

## 11.3 功能描述

AHB 安全控制器支持通过寄存器编程来使能 SRAM 访问、AIPS 槽位访问和 APB 外设访问。当检测到安全违规时，AHB 安全控制器模块会触发中断。AHB 安全控制器还会记录违规信息，例如发生违规时从设备端口正在被访问的地址，以及生成未授权访问的主设备的访问类型和安全属性。

只有在安全且特权模式下运行的应用程序才能向 AHBSC 写入数据以配置安全属性。从应用程序的角度来看，来自 CPU0/CPU1 的最高层级（tier-4）线程可以为系统从设备编程安全属性。在深度睡眠保持（deep-sleep retention）模式期间，编程在 AHB 安全控制器中的寄存器会被保留；然而，从深度睡眠保持模式唤醒后，必须对这些 AHB 安全控制器寄存器重新编程。

Armv8-M TrustZone 是 Arm Cortex 系列中提供的一项新特性，它能够在同一 CPU 上运行时，实现可信（安全）软件的执行分离，以及可信资源对不可信（非安全）软件和资源的访问控制隔离。这种安全控制是通过将存储器阵列和外设分割为安全（S）或非安全（NS）来实现的。Armv8-M TrustZone 针对需要实时响应能力的低能耗嵌入式应用进行了优化。

如果启用了 TZ-M 功能，M33 内核遵循以下规则：

- 处于安全态的 CM33 CPU（CPU-S）只能执行来自安全存储器（S-memory）的指令；它不能从非安全存储器（NS-memory）执行指令。
- CPU-NS 只能执行来自 NS-memory 的指令，不能执行来自 S-memory 的指令。
- CPU-NS 只能访问 NS-memory 中的数据；即 CPU-NS 只能从 NS-memory 执行数据读取，且只能向 NS-memory 执行数据写入。CPU-NS 不能访问来自 S-memory 的数据。

总结如下：

- 安全代码不会因疏忽或故意破坏、修改 NS 代码或数据，从而造成故障或危险。
- 安全（S）应用程序代码不信任非安全（NS）应用程序代码，并禁止 CPU-NS 的越权访问。

为了支持安全态，Cortex-M33 架构进行了扩展，包括安全 MPU、安全 NVIC、安全 SYSTICK、AHB 安全控制器以及带有栈阈值检查的安全栈指针。

#### 11.3.1.1 状态转换

在复位释放时，CPU0/CPU1 (CM33) 处于安全态。

CPU 可以从 CPU-S 状态通过执行新引入的指令来调用 NS 应用程序代码：

- **BXNS**：分支并交换至非安全态（Branch and Exchange Non Secure）——跳转到 NS-memory 中的地址。
- **BXLNS**：带链接的分支交换至非安全态（Branch with Link Exchange Non Secure）——调用 NS-memory 中的子程序。

执行 BXNS 或 BXLNS 指令后，CPU-S 将切换到非安全态（CPU-NS），从而进入从 NS-memory 执行代码的正确状态。

当 CPU 处于 NS 状态时，无法直接访问 S-memory。然而，TZ-M 为 NS 应用程序代码提供了一个进入 S-memory 的网关，称为**非安全可调用（NSC）**区域。NSC 区域位于 S-memory 中，因此 CPU 必须处于 CPU-S 状态才能执行该区域内的指令。S-memory 的 NSC 区域为 NS 应用程序代码访问 S-memory 中的函数提供了一个“门面”（veneer），而无需泄露安全函数的具体地址。

当从 CPU-NS 切换到 CPU-S 时，实现了一个额外的门控因子，即**安全门（SG）**指令。它被放置在 NSC 区域内，位于可被非安全代码调用的安全函数起始处。当调用进入 NSC 区域时，CPU-NS 必须瞄准带有 SG 指令的地址。SG 指令是从 CPU-NS 跳转时唯一可以执行的指令。执行 SG 指令后，CPU 将从 CPU-NS 切换到 NSC 区域状态。如果 CPU-NS 调用了 NSC 区域中不是 SG 指令的地址，则会产生安全故障（Secure Fault）。

安全应用程序开发者在 NSC 区域内创建指向 S 应用程序代码的函数调用，从而允许 NS 应用程序具备访问 S-memory 内部函数的能力。

### 11.3.2 归属单元（Attribution units）

Armv8-M TrustZone 的实现由安全归属单元（SAU）和实现定义归属单元（IDAU）组成。设备归属单元（DAU）通过 IDAU 接口连接到 CPU0。

SAU 和 IDAU 的组合为来自 CPU0 的特定地址分配特定的安全属性（S、NS 或 NSC）。来自 CPU0 的访问（取决于其安全状态以及由 IDAU 和 SAU 设置的结果安全属性）随后将由安全 AHB 控制器与特定的检查器进行比较，该检查器标记了存储器和外设的各种访问策略。
![image.png|600](https://lincx-img.oss-cn-shanghai.aliyuncs.com/img/20260105135720460.png)

#### 11.3.2.1 设备归属单元 (Device Attribution Unit)

该芯片实现了一个简单的归属单元，将整个存储器映射划分为安全或非安全区域。所有外设和存储器都在两个位置具有别名。

- **地址 0x0000_0000 至 0x1FFF_FFFF**
  - 始终为非安全 (Non-secure)
- **地址 0x2000_0000 至 0xFFFF_FFFF**
  - 如果地址第 28 位 = 0，则为非安全
  - 如果地址第 28 位 = 1，则为安全

#### 11.3.2.2 安全归属单元 (Security Attribution Unit)

SAU 位于 CPU0/CPU1（带 TZ 的 CM33）内部。它监测来自 CPU0/CPU1 的所有地址，并根据该地址是 S 还是 NS 分配属性。SAU 不监测除 CPU0/CPU1 之外的总线主设备的地址。

SAU 支持多达 8 个区域描述符，每个描述符允许从以下属性中为特定存储区域设置安全状态：

- **S** – 安全
- **NS** – 非安全
- **NSC** – 非安全可调用

然而，**0xF000_0000 至 0xFFFF_FFFF** 范围固定为安全，SAU 无法将其配置为 NSC。

SAU 只能由处于安全态的 CPU0/CPU1 进行配置。使能后，SAU 默认将所有地址视为 S。只有安全应用程序代码可以编程描述符以创建 NSC 或 NS 区域。

IDAU 与 SAU 协同工作，为特定地址分配特定的安全属性（S 或 NS）。IDAU 和 SAU 都会对特定地址做出响应，CPU0/CPU1 选择两者中较高的安全属性，其中最高状态为 Secure，最低状态为 NS。NSC 属性由 SAU 定义。在 IDAU 中，NSC 区域可以被定义为 NS。区域以 32 字节边界对齐。

从存储器映射的角度来看，对于 0x0000_0000 至 0x0000_FFFF 范围内 64kB 的相同物理程序存储器空间，NS 地址空间是安全地址空间的别名。如果物理地址空间被配置为非安全，非安全应用程序代码将在 0x0000_0000 至 0x0000_FFFF 的非安全 (NS) 空间（地址第 28 位 = 0）中取指；如果物理地址空间被配置为安全，则安全应用程序代码将在 0x1000_0000 至 0x1000_FFFF 的安全 (S) 空间中执行。同样地，安全应用程序代码将访问 0x5000_0000 至 0x5FFF_FFFF 空间（地址第 28 位 = 1）中的所有外设，而 NS 应用程序代码将访问 0x4000_0000 至 0x4FFF_FFFF 空间中的 NS 外设。SAU 可编程寄存器的详细信息可以在 Arm CM33 文档中找到。

下图显示了如何使用 SAU 创建安全和非安全别名。

#### 11.3.2.3 区域编号与测试目标指令

IDAU 为每个区域生成一个区域编号（RN），应用程序代码可利用该编号确定该区域的安全级别。RN 是一个 8 位数字。在该设备中，IDAU 返回的区域编号为：

IDAU_RN[7:0] = ({4'h0, idau_addr_a[31:28]})

SAU 也会返回关于 TT 指令的信息，指示 NS 或 S 属性。

应用程序可以在区域的起始和结束地址上使用测试目标指令（TT）。该指令返回 RN 和安全属性（NS 或 S）。

### 11.3.3 安全 AHB 总线与安全 AHB 控制器

CM33 TZ-M 的实现包含 IDAU 和 SAU 模块，它们根据分配给该地址空间的特定安全属性（S、NS 或 NSC）来过滤来自 CPU0/CPU1 的地址访问。该芯片通过安全 AHB 总线实现了第二层保护，以支持系统级的安全可信执行。

安全 AHB 控制器通过检查器（checker）功能为所有总线从设备提供访问策略。所有主设备都会输出安全边带信号 **HPRIV**（特权）和 **HNONSEC**（安全访问），作为给定访问安全属性的指示。安全 AHB 总线处理这些信号，并将其与安全 AHB 控制器中为从设备设置的安全属性进行比对。如果请求访问的安全属性未违反所访问从设备的安全属性，则授予访问权限。

如果数据或指令访问发生违规，则会触发安全违规异常中断。CPU0/CPU1 切换到安全模式以处理该违规。

边带信号创建了四个安全层级（security tiers）。允许数据访问从高层级主设备流向相同或低层级的从设备。然而，指令访问更加严格，主设备只能访问处于相同安全层级的从设备。系统中提供了一个特殊的可编程选项，允许将系统中的所有访问都视为指令访问，这意味着数据访问检查器也可以变得同样严格。

这种保护是通过三个主要组件实现的：


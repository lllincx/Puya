# 摘要

第 1 章 引言  
介绍嵌入式安全生态系统的背景材料，并讨论谁可能攻击设备以及攻击可能采取的形式。

第 2 章 系统安全  
概述已部署到嵌入式设备中的若干现有安全技术，包括其优点与局限。本章还概述 ARM TrustZone 技术的设计理念，以及它如何吸收并融合多种替代方案的长处。

第 3 章 TrustZone 硬件架构  
详细描述 ARM TrustZone 技术，以及它对系统基础组件的影响。  
本章分为三部分：第一部分关注 TrustZone 技术对系统基础设施的影响；第二部分讨论该技术对 ARM 处理器内核的影响；最后一部分介绍对调试架构的改动。

第 4 章 TrustZone 硬件库  
概述 ARM 提供的支持 TrustZone 的外设 IP。  
本章还给出一些设计建议，以便在系统设计中对基于 AMBA2 AHB™ 接口的现有 IP 进行有限集成。

第 5 章 TrustZone 软件架构  
介绍在使用实现了 ARM 安全扩展（ARM Security Extensions）的 ARM 处理器时，可选的软件设计方案。

第 6 章 TrustZone 系统设计  
给出一个系统设计示例，并以数字版权管理（DRM）与移动支付作为示例用例。

第 7 章 设计检查清单  
在基于 TrustZone 技术进行系统设计或评审时，可使用本章的检查清单作为提示与核对依据。

# 第 1 章 引言

本章提供与嵌入式系统安全相关的背景信息。

## 1.1 什么是“安全”？

在高度抽象的层面上，“安全”可涵盖设计中的多种不同底层特性。本质上，它是系统的一种属性，用以确保有价值的资源不会被复制、破坏，或被使其对合法用户不可用。每个系统设计所需的安全属性各不相同，取决于其试图保护的资产类型与价值，以及面临的恶意攻击。

### 术语

- 资产（Asset）  
   值得保护的有价值资源。既可以是有形对象（如用户密码），也可以是无形资源（如网络可用性）。
- 攻击（To Attack）  
   在未获许可的情况下，有意尝试获取、破坏或扰乱某项资产。  
   攻击方式可能包括恶意软件、硬件监测以及硬件篡改。
- 防御（To Defend）  
   通过在系统中设计并集成软硬件机制来对抗攻击、提供相应对策的行为。

### 1.1.1 基本安全属性

几乎所有更高层次的安全属性都建立在以下基本属性之上：机密性与完整性。

#### 机密性（Confidentiality）

资产具有机密性，表示在给定的攻击集合下，资产不可被复制或窃取。  
该属性对密码、加密密钥等资产至关重要。

#### 完整性（Integrity）

资产具有完整性，表示在给定的攻击集合下，资产免受未授权修改。  
该属性对于设备上的某些根密钥（系统其余安全性的基础）以及已运行的安全软件尤为关键。

#### 真实性（Authenticity）

在某些场景中，设计无法直接保证完整性，此时可提供真实性：即便攻击者改变了资产的值，防御方也能在资产被使用之前检测到变更，从而在攻击导致安全故障之前进行阻断。
该属性对安全软件至关重要。若攻击者能够在程序代码被加载到安全执行位置之前进行篡改且不被检测到，那么该软件所提供的安全性将被绕过。

### 1.1.2 安全方案的局限性

所有安全方案都只能防御其可能遭遇的攻击集合中的一部分。要防御所有可能的攻击在实践中是不可能的；总会有人愿意投入大量时间和金钱，利用非常复杂的手段攻破任何安全方案。因此，设计必须明确要保护的资产，以及要防御的攻击类型。这或许是设计过程中最关键的一步：如果保护了错误的资产，或基于不正确/不完整的攻击清单来防御，设计将很容易被攻破。

既然默认立场是：只要时间和资金足够，任何安全都可能被突破，那么设计的安全需求不应表述为“绝不可能被绕过”，而应以价值量化的方式来表述：“对资产 B 的攻击 A 至少需要 Y 天和 Z 美元”。如果一组对策使得成功攻击所需时间过长或成本过高，那么该防御就是成功的。在这种情况下，大多数攻击者会转向其他目标。

## 1.2 安全性的必要性

嵌入式设备正在处理价值日益提升的数据，例如消费者的银行凭据。同时，这些设备稳步演进为具有高度对外互联能力的开放软件平台，使用户能够下载任意第三方应用。这使设备处于高风险境地。在桌面环境中，开放平台、任意应用下载与设备上存在的高价值资产相结合，已被证明会显著提高安全漏洞被利用的风险。此外，随着流经这些系统的数据价值上升，攻击者越可能投入精力去攻破它们。

ARM TrustZone 技术的目标，是让设备同时受益于功能丰富的开放操作环境与稳健的安全方案。通过良好设计的系统硬件架构与恰当的安全软件设计，无论较不受信任的操作环境如何运行，都能确保敏感数据保持安全。

### 1.2.1 硬件强制的安全

让嵌入式产品免受恶意攻击，会影响到整个系统的设计。设备中的软硬件必须协同工作，才能针对正确类型的攻击提供稳健的安全对策。可信计算组织（Trusted Computing Group）的白皮书 _“Securing Mobile Devices on Converged Networks”（在融合网络中保护移动设备安全）_ 指出：防护最完善的系统，会从设计之初就纳入专用的硬件安全措施——起始于处理器内核与 SoC 基础设施的规格阶段。在这一早期阶段充分考虑硬件安全，能够将某些防护直接内建进设备，而这些防护在后续设计流程中将几乎不可能再补加。
ARM TrustZone 技术通过把防护措施集成到 ARM 处理器、片上总线结构（bus fabric）以及系统外设 IP 中，实现这一层面的系统级安全。 借助软硬件一体化的组件组合，TrustZone 提供了一个框架，使各类安全系统架构都能以对整机成本影响最小的方式落地实现。

## 1.3 面临哪些威胁？

在深入 TrustZone 硬件架构细节之前，需要先弄清本上下文中的“安全”含义，并权衡攻击带来的风险与预防的成本。只有掌握这些信息，系统设计者才能合理决定要保护哪些资产，以及对软硬件防护投入多少。

跨越多种应用与行业的案例表明：嵌入式系统一旦抗攻击失败将付出代价。有的攻击（如支付欺诈）会直接让服务提供商承担损失；另一些（如给机顶盒加装改造芯片）则会在设备生命周期内造成长期收入流失。

### 1.3.1 行业概览

各个市场试图保护的敏感资产类型各不相同。例如，移动终端要保护无线网络的完整性；电视机顶盒要防止未经授权访问付费频道。被保护资产的类型与价值差异叠加底层系统实现差异，导致每个领域遭遇的攻击也不同。本节简要回顾 TrustZone 可能部署的一些市场的安全历史。

#### 移动行业（Mobile sector）

GSM 手机的两个关键要素：

- IMEI（国际移动设备识别码）：设备接入网络时用以识别的 15 位唯一编码；
- SIMLock 协议：将设备与特定运营商的 SIM 卡绑定。

二者均提供安全功能：IMEI 用于阻止被盗手机入网；SIMLock 用于在合约期内将设备绑定运营商。然而在许多手机上，这两种保护常被轻易绕过——通常只需一根 USB 线和一台运行重编程工具的电脑。

这些实现层面的不安全带来了大规模欺诈的机会。据路透社英国版统计数据：手机盗窃驱动了相当比例的街头犯罪，并让行业每年损失以十亿美元计。

当下对新移动设备的安全要求已不再只聚焦网络，还包括本地内容与服务：如通过 DRM 保护数字媒体内容，以及保护机密用户数据（如已同步的邮箱账户）。随着运营商和用户希望从设备获取更多价值，这些保护日益关键。

#### 消费电子与嵌入式行业（Consumer electronics and embedded sector）

便携式游戏机、家用影像播放器等的需求正与移动市场趋同：更强的有/无线连接、更大量的用户数据存储、可下载的可编程内容、更高价值服务的处理——都指向对高性能且稳健安全环境的需求。

安全攻击并不限于开放、可扩展的软件栈。在汽车电子中，多数系统是封闭或深度嵌入式，但调表欺诈（回退里程数抬高二手车价格）依然普遍。美国交通部报告称，该欺诈每年让美国消费者为虚高车价多付数亿美元。

这些嵌入式系统常见的安全需求包括：验证固件更新的真实性，以及确保调试机制不被恶意滥用。基于 ARM TrustZone 的良好系统设计可以满足这些要求。

## 1.3.2 安全问题的经济价值

几乎所有安全设计都通过风险分析来论证：平衡成功攻击的概率、一旦成功带来的业务损失、以及防御成本。有时攻击概率过低，不值得防御；有时合适的防御成本相对资产价值过高。但在多数情况下，某种形式的资产防护具有经济合理性。

接下来的章节将表明：ARM TrustZone 技术有望降低实现安全方案的成本。其架构可降低系统复杂度，进而减少设计/开发/测试成本。仅从经济角度，这使系统能够保护更广泛的资产集合，超出以往的能力范围。

许多潜在攻击者同样可以被视为受经济动机驱使。行业中最大的损失多源于职业黑客而非终端用户，而职业黑客的主要动机是经济收益。他们在一次攻击上的投入不会超过其对财务回报的合理预期。

### Class-breaking attacks（“类攻破”）

许多针对设备的攻击由职业犯罪分子、学术界的安全研究人员以及在家动手的爱好者推动。无论是为了经济收益、学术声望，还是单纯为了好玩，这些群体都可能投入大量时间来分析系统，并开发旨在攻破系统的复杂攻击。

这类攻击最追求的结果是类攻破（class-break）：一种易于复现的攻击，可用来攻破整整一代或同一类别的设备。最广为报道的案例多见于消费类娱乐设备，例如针对游戏机的软件限制的破解，以及针对 DVD 影片内容保护方案的攻击。

在许多对设备硬件下手的类攻破场景中，攻击者的前期探索性研究可能花费不菲。这笔资金用于获取进行硅层级分析的工具，如电子显微镜和晶体管激光激励器。此类攻击的目标，是发现可在多台设备上以低成本重复利用的安全弱点。如果可被攻击的设备数量足够大，这些类攻破会在经济博弈中显著倾向攻击者。

### Positive economics（正向经济效应）

安全环境带来的收益并不只限于技术层面。研究表明，易用且安全的支付系统能提升消费者信心，最多可促进约 20% 的消费增长，同时也加速新营收渠道与不同商业模式的落地。  
设备制造商越来越处于一个消费者具备安全意识的世界中，设备的安全特性正成为竞争差异化的议题。安全评价良好、具备实用安全功能的设备，会优先于规格较差的设备被选择。这在企业级部署尤为真实：移动设备可以连接内部网络。将机密电子邮件与日程同步到智能手机非常有用，但正如《华盛顿邮报》所报道，如果设备丢失或被盗，会让企业面临高风险。许多公司因此限制对企业网络的访问，降低智能设备的价值，或要求设备本身具备额外的安全机制。

---

## 1.3.3 设备如何被攻击？

设计中下一个最重要的因素，是实施攻击所采用的机制。不同的实施方式被称为攻击向量（attack vectors）。本文将其分为三类：hack 攻击、shack 攻击、lab 攻击。

### Hack attack（纯软件攻击）

Hack 攻击指攻击者仅能执行软件层面的攻击。示例包括通过有线或无线连接下载到设备上的病毒与恶意软件。  
在许多成功的 hack 攻击中，设备用户会在不经意间同意安装随后执行攻击的软件。这要么是因为恶意软件伪装成用户本想安装的软件，要么是因为用户不理解操作环境弹出的警告信息。  
《Securing Java》一书中有一句话概括了典型用户在“安全”与“诱人功能”之间的抉择能力：  
“在会跳舞的猪和安全之间作选择时，用户每次都会选会跳舞的猪。”

### Shack attack（低预算硬件攻击）

Shack 攻击是使用低成本硬件实施的攻击，这些设备可在街边电子商店（如 Radio Shack）购得。在这类场景中，攻击者对设备拥有物理接触，但没有足够的设备或专业能力去攻击芯片封装内部。  
攻击者可能尝试利用 JTAG 调试、边界扫描 I/O、内建自测（BIST）等接口连接设备；也可能使用逻辑探针与网络分析仪被动监测，嗅探总线、引脚与系统信号。此外，他们还可能进行一些简单的主动硬件攻击，例如强制引脚/总线为高或低电平、重编程存储器器件，以及以恶意替代品更换硬件组件。

### Lab attack（实验室级攻击）

实验室级攻击向量是最全面、最具侵入性的。如果攻击者能够使用实验室设备（例如电子显微镜），他们就可以对设备进行“无限制”的逆向工程。必须假定攻击者可以对设计中任何敏感部分进行晶体管级逆向——包括逻辑与存储单元。

攻击者可以对设计进行逆向，在硅片金属层上连接微型逻辑探针，并使用激光或其他技术对运行中的电路进行故障注入（glitch）。攻击者还可以监测模拟信号（如设备的功耗与电磁辐射），以实施诸如密码密钥分析之类的攻击。

在大多数情况下，鉴于“任何设备最终都可能被攻破”的经验法则，设备不应直接试图防御实验室级攻击，而应采取限制损害的措施，使一旦设备被攻破也不具备经济可行性。例如，使用每设备唯一的机密：对单台设备进行逆向并不能向攻击者提供对其他设备有用的信息——他们仅得到自己手里这台设备的密钥，而并非该类别中其他设备的密钥。

注意（Note）  
TrustZone 技术旨在在安全组件与 SoC 其余基础设施之间提供硬件强制的逻辑隔离。  
实验室级攻击超出了 TrustZone 技术所提供保护的范围；不过，若某些资产需要物理攻击防护，采用 TrustZone 的 SoC 可以与 ARM SecurCore© 智能卡配合使用。

---

## 1.3.4 谁在攻击设备？

当设计者识别出资产及其可能遭受的攻击后，接下来就需要识别可能的攻击者。不同攻击者会采用不同类型的攻击，某些资产也只会吸引特定类型的攻击者。此类分析有助于理性化每项资产需要防御哪些攻击。

分析还应包括对那些被显式信任访问设备中资产的主体进行说明，这能暴露安全模型中的薄弱点。已有多起公开案例显示，维护/维修技师从设备中窃取消费者数据并随后在互联网发布。

### Remote attacker（远程攻击者）

传统视角下的攻击者是我们在桌面环境中见到的恶意软件分发者：病毒与其他恶意程序。此类攻击者无法物理接触目标设备（尽管可能拥有一台类似设备用于开发攻击），他们依赖软件漏洞与用户失误来获取对敏感资源的访问。

嵌入式设备的软件复杂度不断上升，可被利用的缺陷在统计上也随之增多。支持安装第三方代码（包括执行浏览器内容）的能力，使得将恶意代码送达设备并实施攻击更加容易。

### Security specialist（安全专家/高能力攻击者）

技术能力最强的攻击者包括犯罪团伙、安全专家以及出于兴趣而攻击设备的用户。这类群体有能力发起实验室级攻击（见第 1-10 页的描述）。  
这类攻击者通常试图发现一种可在大量设备上复现的类攻破（class-break）。而后续的“批量化”攻击可能由另一名攻击者来部署。

### Trusted developer（受信任的开发者/内部人）

一种常被忽视的攻击来自被视为可信的人（实施或至少协助）。屡有公司员工因窃取与设计相关的机密信息或故意破坏内部网络而登上新闻头条。在许多案例中，这些员工在攻击曝光前一天仍被明确视为可信。

从经济性角度论证这类防御：贿赂一位掌握设计资料的人，往往比对一块硅芯片进行逆向更便宜、更快捷。

尽管此类攻击难以彻底防范，但可以通过业务流程采取一些防御措施：例如限制对敏感资料的访问，并审计访问记录。

### Device owner（设备所有者）

本文将讨论的最后一类攻击者是设备所有者本人。这类攻击者的典型目标是免费获取服务与内容。一般而言，设备所有者通常有动机发起攻击，但技术能力不足。技术专家会先行开发出攻击方法并将细节发布到网上；设备所有者只需照着教程操作即可复现。

值得注意的是，这类设备所有者会让自己暴露在高于常态的风险之下。因为在尝试破除现有防护时，他们可能误从黑客运营的网站下载打包好的攻击软件；这些网站往往夹带病毒或其他恶意程序，用户随后会在不知情的情况下把它们安装到自己的系统中。

# 第 2 章 系统安全

本章在介绍 ARM TrustZone 硬件架构之前，先概述嵌入式系统中已有的安全选项。

## 2.1 系统安全

嵌入式设备的系统设计十分复杂：既包含多个相互独立的处理器内核，也包含作为次级总线主设备的 DMA 引擎等，以及数量庞大的存储器与外设总线从设备。除这些功能性组件外，系统中通常还并行存在一套基础设施，用于提供侵入式与非侵入式调试能力，以及边界扫描与内建自测（BIST）等设施。

平台中的每个子系统在设计与集成时，都必须与整体安全方案协同，而不是在脱离安全需求的情况下各自为政。若设备的威胁模型表明需要防御 shack 攻击，则仅加固系统的功能部分是没有意义的；一名能够不受限制地访问调试端口的攻击者，往往可以绕过许多原本存在于功能部分的防护。

本节将回顾历史上市场上可用的一些安全架构，并说明其优势与不足。

## 2.1.1 外置硬件安全模块

嵌入式应用的经典安全方案，是在主 SoC 之外加入一个专用硬件安全模块或受信元件（trusted element）。例如：手机中的 SIM 卡、机顶盒中的条件接入智能卡。

### 优点

- 物理封装资产：将需保护的资产封装在为强安全而设计的独立物理器件中。
- 独立流程与工艺：采用与主 SoC 完全分离的设计/制造流程，可使用更高抗篡改与物理安全等级的工艺与技术。
- 合规认证成熟：智能卡的制造与个性化流程常通过官方评估体系的形式化认证，适用于需要高安全保证的场景（如信用卡/借记卡支付）。

### 缺点

- 不适配常规 SoC 设计：智能卡采用的硬件技术与流程对标准 SoC 不现实；引入将显著增加设计工作量，并牺牲面积、功耗效率与性能。
- 性能与资源受限：为获得物理安全而采用的制造方式通常导致处理器性能较低（约 5–20 MHz）、片上 RAM 较少。因此仅适合从非易失存储器运行的相对静态程序，且不适合需要跨安全边界的持续高带宽通信的用例。
- 界面受制于宿主：智能卡仅提供计算与安全存储，无法直接访问宿主设备的任何用户界面。其必须依赖安全边界外的较不安全软件来提供交互，因此无法保护所有相关资产。例如，用户输入 PIN 码需由智能卡外的较不安全软件处理，因而易受攻击。
- 商业成本高：在主 SoC 之外另配智能卡成本高。对多数资产而言，其经济价值不足以支撑这笔额外开销，商业劣势往往大于技术劣势。

## 2.1.2 片内硬件安全模块（Internal HSM）

将硬件安全模块集成到 SoC 内部，放弃了智能卡那类强物理防护，但换来成本降低与系统集成便利。

集成模块的具体形态多样，主要有两类：

1. 密码学加速与密钥存储模块（专用硬件块）；
2. 通用安全处理引擎（与主处理器并列，通过定制硬件逻辑阻止对敏感资源的未授权访问）。

### 优点

- 显著的成本下降与性能提升：相对外置智能卡方案更经济、更高效。
- 通用安全处理器方案的安全性：若为安全子系统配置专用的通用处理器，其安全性与 TrustZone 硬件方案大体相当。

### 缺点

与智能卡类似，密码学模块也存在安全边界受限的问题，因此它通常只能保护加密密钥材料本身。密码学是工具而非目的；被密码方法保护的资源不可避免地要在模块之外被使用，一旦离开加密模块，它们就不再受其保护，因而可能遭到攻击。

与 TrustZone 系统相比，那些为安全子系统配置第二个通用处理器的设计也有一些小缺点。其一，需要一颗独立的物理安全处理器：它通常性能弱于主应用处理器，同时占用可观的硅面积。此外，两个处理器之间的通信要求将任何数据刷新到一致性内存（通常是外部存储器），这一操作耗时且耗能。其二，任何资源隔离都需要在 SoC 内通过专有硬件扩展来实现，这会带来大量的设计与测试工作，并使系统的迁移或扩展更为困难。

这里提到的密码学模块与第二处理器方案通常试图加固系统的功能面；然而，SoC 内用于调试与测试的机制所带来的系统级安全风险往往被忽视，这些机制反而提供了可被攻击的脆弱接口。为避免这一问题，只能彻底禁用调试，但这又会让现场软件问题的诊断变得困难。

## 2.1.3 软件虚拟化

虚拟化是一种软件层面的安全机制：一个高度可信的管理层（称为管理程序/Hypervisor）运行在通用处理器的特权模式下。Hypervisor 通过内存管理单元（MMU）将其上运行的多个独立软件平台隔离，把每个平台置于由 Hypervisor 控制的虚拟机中。

某些 Hypervisor 体量精简、代码紧凑；若其能够被充分测试，则由其管理的某个虚拟机内的软件可以有理由相信：自己不受其他虚拟机内软件的攻击。

注意（Note）  
本节描述的是半虚拟化（paravirtualization），这类虚拟化在嵌入式市场中最常见。也有一些处理器架构为 Hypervisor 提供专用处理器模式，允许 Hypervisor 直接托管一个完整操作系统；随后该操作系统再利用 MMU 对 Hypervisor 分配给它的内存空间进行二次划分。

### 优点

- 任何带 MMU 的处理器都能实现虚拟化方案；常见的富操作系统（Rich OS）也已有在其上运行的移植版本。
- 实现 Hypervisor 无需额外硬件。
- 安全敏感型应用可移植到 Hypervisor 之上的安全环境中运行，而不暴露在富操作环境之下；Hypervisor 还能提供通信机制，以便各软件虚拟机之间通信。

### 缺点

- 虚拟化的隔离仅限于承载 Hypervisor 的处理器本身。系统中的其他总线主设备（如 DMA 引擎、GPU）可以绕过 Hypervisor 的保护；因此必须由 Hypervisor 统一管控这些主设备，才能落实所需的安全策略。
- 在不损害系统性能的前提下要做到这一点非常困难；例如，要在不降低图形性能的情况下对可编程 GPU 的复杂输入进行验证，超出了大多数虚拟化方案的能力范围。
- 虚拟化忽略了与硬件攻击相关的安全问题，例如利用调试或测试基础设施的威胁。要让虚拟化系统对这类攻击保持安全，必须彻底禁用调试与测试可见性；但这会让软件开发以及现场缺陷诊断变得非常困难。

## 2.2 TrustZone 硬件安全

上一节那些安全体系之所以有问题，要么是因为它们只能在受限的系统局部保护部分资产，要么是因为它们忽视了大块攻击面。很多情况下，这种“局部而严苛”的设计反而保护错了资产。例如，密码学硬件模块主要保护密钥——这当然很重要——但如果攻击者能在密码模块之外的媒体播放器中反复窃取已解密内容，那么仅保护密钥对内容权利方而言意义有限。

现实中对设备的攻击类型广、手段多，覆盖了本章前面概述的全部攻击画像。任何只针对其中一个威胁面的安全方案，等于忽略了一半以上的问题，无法抵御现实世界中的大量攻击。结果就是，许多方案的实际安全水平低于其目标，许多资产因此保护不足。

### 2.2.1 系统级安全（System-wide security）

ARM 在嵌入式领域实现可信计算的思路是：可信平台。也就是把安全基础设施贯穿整个系统设计的硬件架构。与其在某个专用硬件块里“圈地自保”，不如让 TrustZone 架构使系统中的任何部分都能被标记为安全域，从而形成端到端的安全方案——既覆盖功能单元，也覆盖调试基础设施。

在此架构之上配套合适的安全协议（如安全启动、认证调试开启），可以对大量 Hack/Shack 攻击建立对策。再结合缓解实验室级攻击风险的方法（例如为每台设备配置统计唯一的机密），就能形成更强韧的整体解决方案。

# 第 3 章 TrustZone 硬件架构

本章将详细介绍 TrustZone 硬件架构，并说明其对系统互联结构（fabric）、处理器以及调试基础设施的影响。

## 3.1 概述

TrustZone 硬件架构旨在提供一个安全框架，使设备能针对其将遭遇的多种特定威胁进行防护。它并非“一刀切”的固定方案，而是提供一套基础设施，让 SoC 设计者可从多种组件中选择，分别承担安全环境中的特定功能。

该架构的首要安全目标其实很直白：构建一个可编程环境，使几乎任何资产的机密性与完整性都能针对特定攻击得到保护。 具备这些特性的平台，能以传统方法难以具备的成本效益，构建覆盖面更广的安全解决方案。

系统的安全性通过对 SoC 的全部软硬件资源进行分区来实现：资源要么处于安全世界（Secure world），要么处于普通世界（Normal world）。在支持 TrustZone 的 AMBA3 AXI™ 总线结构中，硬件逻辑确保普通世界无法访问安全世界资源，从而在两者之间建立强健的安全边界。只要将敏感资源置于安全世界，并在安全处理器内核上运行稳健的软件，几乎任何资产都能防御多类攻击，甚至包括通常难以保护的场景，例如通过键盘或触摸屏输入的口令。

TrustZone 硬件架构的第二个方面，是在部分 ARM 处理器内核中加入的扩展：它们使单个物理内核能够安全且高效地以时间片方式执行普通世界与安全世界的代码。这样就无需专用的安全处理器内核，从而节省硅面积与功耗，并让高性能安全软件能与普通世界操作环境并行运行。

第三个方面，是具备安全感知的调试基础设施：在不影响普通世界调试可见性的前提下，可控地管理对安全世界调试的访问。

## 3.2 系统架构

对系统 IP 的架构改动提供了将硬件资源划分为两大世界的机制。本节说明这些改动的影响及被修改的组件。

### 3.2.1 AMBA3 AXI 系统总线

扩展后的总线设计中，最重要的变化是：在主系统总线的读/写通道各新增一根控制信号位，称为 Non-Secure（NS）位，其定义见公开的 AMBA3 AXI 规范：

- AWPROT[1]：写事务；低电平表示 Secure，高电平表示 Non-secure。
- ARPROT[1]：读事务；低电平表示 Secure，高电平表示 Non-secure。

所有总线主设备在发起事务时都必须设置这些信号；总线或从设备的译码逻辑须据此判定以确保不违反安全隔离。所有 Non-secure 主备设在硬件上必须将其 NS 位置为 高，从而无法访问 Secure 从设备：地址译码不会命中任何 Secure 从设备，该事务将失败。

若 Non-secure 主设备尝试访问 Secure 从设备，具体失败行为由实现决定：要么静默失败，要么产生错误。错误可能由从设备或总线发出，常见为 SLVERR（从设备错误）或 DECERR（译码错误）。

### 3.2.2 AMBA3 APB 外设总线

TrustZone 的一大实用特性是能将外设（如中断控制器、定时器、用户 I/O）纳入安全域，从而把安全从“数据处理环境”扩展到更广的系统问题。例如：

- 安全中断控制器与定时器：支持不可中断的安全任务对系统进行监控；
- 安全时钟源：支撑稳健的 DRM；
- 可设为安全的键盘外设：支持安全口令输入。

AMBA3 规范包含低门数、低带宽的外设总线 APB，通过 AXI-to-APB 桥接到系统总线。APB 不携带 NS 位，以确保现有 AMBA2 APB 外设与 TrustZone 系统一致兼容。因而，AXI-to-APB 桥负责管理 APB 外设的安全：对安全属性不匹配的事务必须在桥上拦截，不得转发至外设。

### 3.2.3 内存别名（Memory aliasing）

将 NS 位加入总线事务以及系统中的缓存标记，可视为引入了“第 33 位地址”。也即：存在一套 Secure 32 位物理地址空间与一套 Non-secure 32 位物理地址空间。与任何地址空间一样（无论是否使用 TrustZone），必须小心保持数据一致性，否则会数据损坏。

设想：Secure 世界的主设备要访问一个带缓存的 Non-secure 从设备，设计可有两种做法：

1. 主设备以 Non-secure 访问该从设备；
2. 主设备以 Secure 访问该从设备，且该 Non-secure 从设备接受 Secure 事务，但按 Non-secure 对待这些访问。

对第二种做法，硬件必须支持地址空间别名：同一物理存储位置在地址映射中呈现为两个不同位置（一个 Secure、一个 Non-secure）。结果是：同一数据可能以多个副本同时存在于缓存中。对于可修改数据，这种别名会引发一致性问题：当修改了其中一个副本而另一个仍留在缓存中时，会出现两个不同版本。

结论：系统设计者必须意识到潜在一致性问题，并采取措施避免（例如统一访问属性、在跨域共享时进行刷新/失效处理、禁用对可变区的别名等）。

## 3.3 处理器架构

最重要的架构性改动体现在实现了架构级安全扩展（Security Extensions）的 ARM 处理器上。目前包括：

- ARM1176JZ(F)-S™
- Cortex™-A8
- Cortex-A9
- Cortex-A9 MPCore™

在这些设计中，每个物理处理器内核都提供两个虚拟内核：一个被视为 Non-secure，另一个为 Secure，并提供一种在它们之间进行稳健上下文切换的机制，称为 Monitor 模式（monitor mode）。

主系统总线上发送的 NS 位的取值由执行相应指令或数据访问的虚拟内核身份间接决定。这使虚拟处理器与系统安全机制的集成非常直接：Non-secure 虚拟处理器只能访问 Non-secure 的系统资源，而 Secure 虚拟处理器可以看到所有资源。

### 3.3.1 世界切换（Switching worlds）

两个虚拟处理器以时间片方式执行；当切换当前运行的虚拟处理器时，通过一种新的内核模式——监控模式（monitor mode）进行上下文切换。

物理处理器从 Normal world（普通世界）进入监控模式的机制受到严格控制，并且在监控模式软件看来，这些进入路径都被视为异常（exception）。进入监控模式可以由软件执行专用指令 SMC（Secure Monitor Call）触发，或由部分硬件异常触发。IRQ、FIQ、外部数据中止（external Data Abort）以及外部预取中止（external Prefetch Abort）都可配置为使处理器切入监控模式。

在监控模式中运行的软件由实现自行定义，但通常会保存当前世界的状态，恢复将要切换到的世界的状态，然后执行异常返回，在被恢复的世界中重新开始执行。

处理器当前所处的世界由系统控制协处理器 CP15 中的安全配置寄存器（SCR）里的 NS 位（NS-bit）指示（当处理器不在监控模式时）。当处理器处于监控模式时，无论 SCR.NS 的取值如何，处理器都在 Secure world（安全世界）执行；但若 SCR.NS = 1，对堆栈的 CP15 寄存器的操作将访问普通世界的拷贝。

> 如果安全世界的软件在非监控模式下把 SCR.NS 置为 1，处理器会立即切换到普通世界运行。这会让低可信软件能够观察到流水线中仍在执行的指令，以及处理器寄存器中持有的任何数据。若这些指令或数据是敏感的，就可能导致安全违规。因此建议只有监控模式的软件直接修改 NS 位。普通世界的软件无法访问 SCR 的内容。

### 3.3.2 保障一级（L1）存储系统的安全

核外的内存基础设施已将系统分成两个世界；在内核内部也需要进行类似的划分，以在一级（L1）存储系统的各组件中隔离其使用与存储的数据。

#### 内存管理单元（Memory Management Unit, MMU）

在 ARM 应用型处理器的 L1 存储系统中，核心组件是 MMU。它把处理器上软件所见的虚拟地址空间映射到处理器外部存在的物理地址空间。地址转换由软件控制的转换表管理，表中记录了每个虚拟地址对应的物理地址，以及与该内存访问相关的其他属性（如可缓存性与访问权限）。

在仅有 MMU 而不支持安全扩展（Security Extensions）的 ARM 内核（如 ARM926EJ-S™）中，任一时刻只有一套虚拟地址到物理地址的映射。特权模式代码通常在进程上下文切换时重写转换表，或让硬件指向另一组表，以提供多个相互独立的虚拟内存空间。

在 TrustZone 处理器中，硬件处理器为两个虚拟处理器各提供一个虚拟 MMU。这使每个世界都拥有本地的翻译表（translation tables），从而独立控制其虚拟地址到物理地址的映射。

ARMv6/ARMv7 的 L1 翻译表描述符（descriptor）格式包含一个 NS 字段。安全（Secure）虚拟处理器据此决定在访问与该描述符关联的物理内存时应使用的 NS 位取值。非安全（Non-secure）虚拟处理器硬件忽略该字段，其内存访问始终以 NS=1 进行。此设计使安全虚拟处理器既可访问 Secure 内存，也可访问 Non-secure 内存。

为实现高效世界切换，ARM 处理器的实现可能会给 TLB（Translation Lookaside Buffers）中的表项（由表遍历缓存而来）打标签，记录发起该遍历的世界身份。这样 Non-secure 与 Secure 的表项可在 TLB 中并存，切换世界时就无需刷新 TLB 表项。

> 在 TLB 标签中记录所属世界身份并非 ARM 架构强制要求，属于实现相关。某些处理器硬件可能会在世界切换时刷新部分或全部 TLB 表项。

#### Caches（缓存）

高性能设计期望缓存同时容纳两种安全状态的数据，这样世界切换时无需清缓存，并能在世界边界上实现高性能通信。为此，L1 缓存以及（若适用）L2 及以上处理器缓存会新增一位标记，记录访问该内存的事务的安全状态。

就安全状态而言，缓存内容是动态的。任何未锁定（non-locked down）的缓存行都可能为新数据腾挪而被替换（evict），不论其安全状态为何。也就是说，Secure 行可以驱逐 Non-secure 行，Non-secure 行也可以驱逐 Secure 行。

![image.png|600](https://pic.lllincx.cn/20251105111423846.png)

把以上各概念合在一起，图 3-2 展示了一个理论上的 ARM 处理器在访问内存系统时，其 L1 存储系统如何处理与安全扩展相关的状态。

1. 核心处理逻辑尝试进行数据读取、数据写入或指令预取。硬件把虚拟地址（VA）以及当前世界（非安全表标识，NSTID）传给 TLB，以便执行地址转换。
2. TLB 载入与所给 VA 和 NSTID 对应的物理地址（PA）与 NS 位；必要时执行页表遍历，并在 NSTID=1 时强制 NS=1。随后 TLB 将这些信息传递给缓存，以执行实际的数据/指令访问。
3. 缓存尝试用来自 TLB 的 PA 和 NS 位去匹配已有缓存行的标记（tag）。若匹配成功，则直接返回该缓存行的数据；否则，从外部内存系统装载该缓存行。

在一个媒体应用中，加密音频由 Normal world 的媒体播放器加载，而在 Secure world 解密。此时，Secure world 的软件可以在其翻译表中映射那片属于媒体播放器的 Non-secure 内存。这样 Secure world 就能直接访问包含待解密音频内容的 Non-secure 缓存行；这类内存称为跨世界共享内存（World-shared memory）。因此，Normal world 的应用可以通过缓存层级的任意一层把数据传给 Secure world 的协作任务。与要求把已缓存数据刷出缓存到外部内存的方案相比，这种做法能实现更高性能。

#### 紧耦合存储器（Tightly Coupled Memories, TCM）

ARM1176JZ(F)-S 处理器支持 TCM：位于与 L1 缓存同一级别的高性能 SRAM 块。依据综合（synthesis）时配置的 TCM 总容量，指令接口与数据接口上各可拥有最多两个 TCM 块。软件可将每个 TCM 块配置为仅 Secure 访问或仅 Non-secure 访问，并且独立控制每个块的基地址。

### 3.3.3 安全中断（Secure interrupts）

可将 IRQ 与 FIQ 直接陷入 Monitor，无需任一世界的代码先介入，从而为安全中断源建立灵活的中断模型。执行流一旦到达 Monitor，可信软件即可按需转发该中断请求。若结合具安全感知的中断控制器，设计即可提供普通世界软件无法篡改的安全中断源。

ARM 推荐模型是：将 IRQ 用作普通世界中断，将 FIQ 用作安全世界中断。由于多数操作环境普遍使用 IRQ，把 FIQ 作为安全中断可将对既有软件的改动降到最少。  
当中断到来时，若处理器正运行对应世界的虚拟核，则无需切换到 Monitor，在当前世界本地处理。若处理器此刻身处另一世界，硬件会陷入 Monitor，由 Monitor 软件触发上下文切换并跳转到被恢复的世界，然后在那里响应中断。

> 建议 Monitor 始终在屏蔽中断（masked）状态下执行。

![image.png|600](https://pic.lllincx.cn/20251105153215182.png)

（图 3-3：一种在将 IRQ 配置为非安全中断时的可能路由方案）

为防止普通世界的恶意软件屏蔽敏感的安全世界中断，处理器在 CP15 内提供了一个配置寄存器，可禁止普通世界软件修改 CPSR 中的 F（FIQ 屏蔽）与 A（外部异常屏蔽）位。该控制寄存器仅能由安全世界软件访问。无法禁止普通世界对 IRQ 中断进行屏蔽。

#### 处理器异常向量表（Processor exception vector tables）

为实现上述异常行为，支持 TrustZone 的处理器实现了三套异常向量表：一套用于普通世界，一套用于安全世界，一套用于 Monitor 模式。

复位时，安全世界向量表的基地址由 VINITHI 输入信号决定：未置位时为 `0x00000000`，置位时为 `0xFFFF0000`。其余两张表的基地址未定义，应在使用前由软件设置。

与早期 ARM 处理器不同，这三张表的位置可在运行时迁移：通过编程 CP15 中相应的 VBAR（Vector Base Address Register）实现。

> 运行时可通过 CP15 控制寄存器中的 V 位启用/禁用高地址向量（High vectors）。若 V=1，处理器异常始终从 `0xFFFF0000` 开始的向量表进入，不受 `VBAR` 的影响。V 位是分组的，可分别为 Secure world 与 Normal world 的向量表独立配置。  
> V 位仅作用于对应的 Secure/Normal world 异常向量表；Monitor 的异常向量表始终位于 Monitor Vector Base Address Register 指定的地址。

## 3.3.4 安全处理器配置（Secure processor configuration）

为使两个虚拟 CPU 能独立执行代码，硬件对 CP15 中的配置项实施严格管控：

- 被视为敏感或对内核全局生效的配置项，仅能由 Secure world 软件写入（多数情况下 Normal world 可读）。
- 非全局敏感、可在各自世界本地生效的设置，通常在硬件中做 banked，使两世界可各自独立控制与其实现相关的参数。

某些仅 Secure world 可修改的全局配置会对 Normal world 的实现产生影响，尤其涉及底层硬件特性（如 cache lockdown、系统协处理器等）的访问控制。不过，遗留软件通常几乎无需修改即可在 Normal world 运行。

## 3.3.5 带安全扩展的多处理器系统（Multiprocessor systems with the Security Extensions）

ARM 架构支持簇（cluster）内 1–4 个处理器的多处理器设计。簇内处理器可配置为：

- SMP（对称多处理）模式，或
- AMP（非对称多处理）模式。

当处理器在 SMP 模式运行时，簇内的 SCU（Snoop Control Unit） 会透明地保持在各处理器 L1 数据缓存中共享数据的一致性。若在 AMP 模式且需要一致性，则需由软件手动维护。

> 注 1：SCU 只对 MMU 支持的内存类型中的一部分提供一致性维护；细节参见相应处理器的 技术参考手册（TRM）。

这些多处理器系统可以实现 ARM 安全扩展（Security Extensions），使簇（cluster）内每个处理器都具备本章前述的程序员可见模型。目前同时实现多处理器特性与安全特性的处理器是 Cortex-A9 MPCore。

> 多处理器系统通常包含 ACP（Accelerator Coherency Port，加速器一致性端口），允许外部总线主设备访问与处理器簇一致的物理内存视图。详见第 3-10 页。

### 每核两世界（Two worlds per processor）

簇内每个处理器都同时具有 Normal world 与 Secure world。因此，一个 4 核簇合计有 8 个虚拟处理器，各自独立控制其 MMU 配置。  
任意时刻，簇中可有任意数量处理器处于 Secure world，且各处理器可彼此独立在两世界间切换。具体的软件实现也可以选择限制 Secure world 的并发执行，以降低复杂软件带来的安全风险。

> 关于多处理对 Secure world 软件设计的潜在影响，参见第 5-13 页 “Secure software and multiprocessor systems”。

正如第 3-8 页 Caches 小节所述，簇内每条缓存行的标记（tag）都会记录其数据的安全状态。在 SMP 模式下，这使 L1 数据缓存可并发存放 Secure 与 Non-secure 数据；一致性硬件在进行维护时使用完整的缓存标记，从而同时保持两种安全状态数据的一致性。

### SCU（Snoop Control Unit）配置

SCU 提供若干配置寄存器，用于确定 SCU 本身、簇内各 ARM 处理器 的配置，以及处理器本地定时器对 Non-secure 内存事务的可达性：

- SCU Access Control Register：决定簇中哪些处理器可以重编程 SCU 的配置寄存器。
- SCU Secure Access Control Register：决定 Non-secure 访问是否可以重编程 SCU 配置寄存器或访问处理器本地定时器。

### 中断处理（Interrupt handling）

Cortex A 系列多处理器系统集成了与 PrimeCell GIC（PL390） 同源技术的中断控制器（见第 4-6 页）。该控制器提供灵活的中断模型，可在多核簇间分发带优先级的中断；当收到更高优先级中断时，可打断正在执行的低优先级中断处理程序。

在同时实现安全扩展的多处理器系统中，该中断控制器对 TrustZone 敏感：能够分别管理 Secure 与 Non-secure 中断，并阻止 Non-secure 内存访问读取或修改 Secure 中断 的配置。

由集成中断控制器管理的某个中断，可以通过设置 Interrupt Security Register（中断安全寄存器）中的相应位被配置为 Secure 中断。一旦中断被设为 Secure，任何 Non-secure 访问都不能再修改其配置。

集成中断控制器管理的所有中断都会被分配优先级，以决定它们是否允许打断处理器正在处理的异常。硬件保证：低优先级中断会等待更高优先级中断被清除后，才会发给处理器。优先级空间被分区，确保 Secure 中断总能被配置为高于 Non-secure 中断的优先级。给 Secure 世界分配高优先级中断，可用来防止 Non-secure 世界利用中断对 Secure 世界实施拒绝服务（DoS）攻击。

本章前文描述的模型也受集成中断控制器支持：其管理的 Secure 中断可触发 FIQ 异常，Non-secure 中断可触发 IRQ 异常。在这种情况下，所有中断都由集成中断控制器管理，不再允许外部中断控制器直接向处理器产生中断。该控制器也支持若干传统（legacy）配置，使 FIQ 和/或 IRQ 异常由外部中断触发，从而完全绕过集成中断控制器。

可以分别为 FIQ 与 IRQ 异常配置 legacy 触发方式：

- 仅为 FIQ 启用 legacy 模式：集成控制器将其管理的 Secure 与 Non-secure 中断都路由到 IRQ 异常向量。
- 仅为 IRQ 启用 legacy 模式：集成控制器将无法为 Non-secure 中断产生异常；Secure 中断将被路由到 FIQ 异常向量。
- 为 FIQ 与 IRQ 都启用 legacy 模式：完全绕过集成中断控制器。

> 若在设计中使用了这类 legacy 中断输入信号，它们通常由一个或多个外部中断控制器产生。对于这些外设，可按 TrustZone 系统中 AXI/APB 从设备相同的方法进行安全化处理。

## 3.4 调试架构（Debug architecture）

与安全扩展（Security Extensions）集成的系统基础设施中，最后一块是调试（debug）。ARM 的调试方案分为两部分：处理器调试组件与系统级调试组件。

### 3.4.1 处理器调试控制（Processor debug control）

在引入安全扩展之前的 ARM 处理器，只有一根全局调试使能信号，用来整体开启/关闭调试器对处理器的访问。若在这类设计里同时部署安全敏感软件与富操作环境，通常意味着必须全局关闭调试，否则会被简单的硬件攻击利用。

随着操作环境越来越庞大复杂，且有大量第三方开发者需要在量产设备（已开启安全软件）上调试应用，这种“一刀切”关闭调试的做法就很不理想。

TrustZone 调试扩展将调试访问控制细分为下列可独立配置的视图（维度）：

- 安全特权态·侵入式（Secure privileged invasive，例：JTAG 停核、读写寄存器）
- 安全特权态·非侵入式（Secure privileged non-invasive，例：trace 跟踪）
- 安全用户态·侵入式（Secure user invasive）
- 安全用户态·非侵入式（Secure user non-invasive）

安全特权态的调试访问由内核的两根输入信号控制：SPIDEN（侵入式）与 SPNIDEN（非侵入式）。  
安全用户态的调试访问则由一个仅安全特权可访问的 CP15 寄存器中的两位控制：SUIDEN（侵入式）与 SUNIDEN（非侵入式）。  
这些设置使 TrustZone 处理器在设备部署后仍可精细控制调试可见性。例如，可以完全开放 Normal world 的调试可见性，同时彻底禁止 Secure world 的所有调试。

> ARM 处理器还提供全局调试使能输入信号：DBGEN，以及（在 ARMv7 内核上）NIDEN。它们可用于关闭某核的一切调试可见性（包括 Normal world）。
>
> - ARMv6：`DBGEN` —— 同时控制侵入式与非侵入式调试的全局使能
> - ARMv7：`DBGEN` —— 侵入式调试全局使能
> - ARMv7：`NIDEN` —— 非侵入式调试全局使能

#### 多处理器调试控制（Multiprocessor debug control）

在实现多处理器扩展的 ARM 处理器中（见 3-13 节“带安全扩展的多处理器系统”），簇内每个处理器都有各自独立的 DBGEN、NIDEN、SPIDEN、SPNIDEN 输入信号。这样就能对簇内部分处理器、以部分方式进行调试。

> 注：SMP 的数据一致性硬件可能会使启用侵入式调试的处理器，去修改另一颗禁用侵入式调试的处理器正在使用的数据。

#### 性能分析（Performance analysis）

为支持低层基准测试，ARMv6/ARMv7 应用级处理器在 CP15 中包含性能监视器（Performance Monitor）。该单元可用于计时代码执行、并统计运行期的处理器事件（如缓存行逐出等）。  
为防止性能监视器被用来攻击 Secure 世界软件，可通过安全的 CP15 配置选项禁止 Normal 世界与用户态访问这些计数器。

---

## 3.4.2 系统级调试控制（System debug control）

ARM 的系统级调试方案是 CoreSight™ 片上调试与跟踪技术。它为整颗 SoC 提供调试/跟踪能力，支持多处理器及其它系统组件；既可由板外工具访问，也可由片上组件访问。

片上硬件/软件可达的 CoreSight 基础设施以 APB 外设形式实现。为减少组件数量，CoreSight 外设设计上不使用 AXI-to-APB 桥按外设提供的标准保护机制；CoreSight 组件应允许 Non-secure 内存事务访问。  
作为替代，CoreSight 组件提供若干控制信号以启用/禁用 Secure 调试——统称 CoreSight 认证接口（authentication interface），包含 SPIDEN、SPNIDEN、DBGEN 等信号，其作用与前述处理器内核上同名信号相同。

当 SPIDEN 为未置位（deasserted）时，若外部调试硬件或目标设备上的 Normal 世界软件尝试在安全地址上设置系统级断点，CoreSight 硬件将无法创建该断点。对于插桩/监测类方案，若 SPNIDEN 未置位，则与 Secure 相关的跟踪信息将被外设直接丢弃。

> 由于该调试安全架构的结果是：当 SPIDEN 或 SPNIDEN 置位时，Normal 世界软件可能直接影响或监视系统中的 Secure 世界执行。因此，安全调试仅应在受信任环境下启用。

# 第 4 章 TrustZone 硬件库

本章概述 ARM 提供的 支持 TrustZone 的 IP（核与外设组件）。

## 4.1 系统 IP

本节概述 ARM 提供、并内建支持 Security Extensions 的部分系统级 IP。

> 注：只要选用合适的 AXI-to-APB 桥，任何 APB 外设都可以在 Security Extensions 框架下实现安全化。

### 4.1.1 PrimeCell® High-Performance Matrix（PL301）

实现系统级隔离的核心组件是符合 AMBA3 AXI 的总线矩阵，用于连接整个平台的各个部件。ARM 以 PrimeCell High-Performance Matrix（PL301）形式提供该能力。

为满足现代 SoC 基础设施的需求，AXI 总线发生器还配套了一系列支撑组件：用于时序隔离的寄存器切片、将总线宽度缩减到低带宽区域的宽度缩减器（downsizer）、以及同步/异步桥以跨越不同时钟域，包括：

- BP130：PrimeCell Infrastructure AMBA3 AXI Register Slice
- BP131：PrimeCell Infrastructure AMBA3 AXI Downsizer
- BP132–BP134：PrimeCell Infrastructure AMBA3 AXI-to-AXI Bridges
- BP135：PrimeCell Infrastructure AMBA3 AXI-to-APB Bridge

在典型 ARM 系统中，大多数外设挂在 APB 总线上。APB 相比主 AXI 总线更简单、功耗更低。APB 协议不承载与 TrustZone 安全状态相关的事务位，这使既有外设设计可以直接复用在 AMBA3 APB 上；相应地，管理安全状态的职责落在 AXI-to-APB Bridge 上，它位于高速 AXI 域与低功耗 APB 域之间的接口处。

每个 AXI-to-APB 桥都提供一个 AXI 从接口，可在其本地 APB 总线上仲裁最多 16 个外设的访问。桥内部包含地址译码逻辑，依据传入的 AXI 事务生成 APB 外设选择信号。为实现安全控制，桥为总线上每个外设提供一根 TZPCDECPROT 输入信号，用于指示该外设被配置为 Secure 还是 Non-secure；当目标地址属于 Secure 外设地址范围时，桥会拒绝 Non-secure 事务。

这些桥接器输入信号既可以在综合（synthesis）时固定连接，也可以通过可信外设（例如 TrustZone Protection Controller, TZPC）动态控制，以便在运行时实现安全状态的动态切换。![image.png|600](https://pic.lllincx.cn/20251106141915476.png)

图 4-1：使用 TZPC 控制 SoC 上的安全信号  
图 4-1 展示了一个控制 4 个外设的 AXI-to-APB 桥。其中 TZPC 被配置为始终为 Secure，Timers 与 RTC 被配置为始终为 Non-secure，而 KMI（Keyboard and Mouse Interface） 的安全状态则可由软件可编程控制。Secure 世界的软件可以在运行时对 TZPC 进行编程，改变送往 AXI-to-APB 桥的信号，从而把 KMI 在 Secure 与 Non-secure 之间切换。

> 图中实心阴影的模块表示 Secure 外设，带阴影角的模块表示可在 Secure 与 Non-secure 间切换的外设。

这种设计允许外设在大多数时间运行于 Normal 世界，但可在短时间内临时切换到 Secure 世界。KMI 就是典型例子：它通常作为 Normal 世界的通用键盘输入，但在需要安全输入用户口令时，可短暂切换为 Secure 输入设备。如图所示，引入 TZPC 还可动态控制 SoC 上的其他信号，例如送往 ARM 内核的 SPIDEN 调试控制输入。

## PrimeCell 基础设施 AMBA3 AXI ↔ AMBA 2 AHB 桥（BP136–7）

AXI-to-AHB 与 AHB-to-AXI 两类桥用于把实现 AMBA3 与 AMBA2 规范的两个子系统互连。每个方向需要一座桥：

- AXI-to-AHB：使 AXI 事务可在 AHB 总线上发起（master）。
- AHB-to-AXI：使 AHB 事务可在 AXI 总线上发起。

安全状态承载： AHB 总线不携带事务的安全状态（NS），因此必须由桥内完成全部安全属性管理：

- AXI-to-AHB 桥：可将整个 AHB 从属域（slave domain）统一设为 Secure 或 Non-secure。
- AHB-to-AXI 桥：可将整个 AHB 主控域（master domain）统一设为 Secure 或 Non-secure。

设计建议： 若系统既有 Secure 又有 Non-secure 的 AHB 主/从，切勿把两类组件放在同一座桥后面。

> AHB 域内的安全性完全由 AHB 侧配置管理，不属于 Security Extensions 的范畴。

---

### 4.1.2 PrimeCell 二级缓存控制器（PL310）

随着处理器频率提升，通常需要在内核与外部存储系统之间加入 L2 Cache，以减少因访问外存延迟导致的流水线停顿，从而显著提升部分应用性能并降低功耗。  
在 TrustZone 系统中，每级缓存的每条缓存行都需要携带数据的安全状态标签，以便两世界数据并存。

- ARM1176JZ(F)-S、Cortex-A9 可使用独立的 L2 控制器，该控制器必须支持安全状态标签；ARM 提供的 PrimeCell PL310 可满足此要求。
  > Cortex-A8 的 L2 控制器为集成式（非外置 PL310）。

### 4.1.3 PrimeCell DMA 控制器（PL330）

使用处理器在系统内搬运数据，会低效地占用功耗与 CPU 时间。因此很多系统加入 DMA 控制器（DMAC），专门在物理内存系统之间搬运数据。

PrimeCell DMA 控制器是一款多通道 AXI 引擎，通过微码化的任务描述支持复杂数据结构的传输。DMAC 可并发支持 Secure 与 Non-secure 通道，每个通道都有独立的中断事件，并通过专用 APB 接口进行控制。若 Non-secure 事务试图编程一次到/从 Secure 内存的 DMA 传输，该 DMA 传输将失败。

---

### 4.1.4 PrimeCell TrustZone 地址空间控制器（PL380, TZASC）

TZASC 是一个 AXI 组件，可把其从属地址范围划分为若干内存区域。可由 Secure 软件对这些区域进行配置，使其成为 Secure 或 Non-secure；对被配置为 Secure 的区域，TZASC 会拒绝 Non-secure 事务访问。

可综合配置项包括：内存区域的数量，以及 TZASC AXI 接口的总线宽度。

主要用途：将单一 AXI 从设备（例如 片外 DRAM）划分为多个安全域。内存器件往往因引脚数、PCB 面积与器件成本而代价较高，因此把一颗外部内存分区为同时包含 Secure/Non-secure 的区域，通常比放置两颗更小的内存器件更经济。

ARM 的 AXI 动态内存控制器（DMC）系列是高性能控制器，本身不支持创建 Secure/Non-secure 分区。为实现安全分区，可将 TZASC 放在 DMC 与 SoC 内主设备之间。TZASC 针对动态内存设计，允许突发访问穿过，尽量不增加内存访问时延。

> 注  
> TZASC 仅用于分区“存储器映射”设备；不能用于分区块设备（如 NAND Flash）。

### 4.1.5 PrimeCell 基础设施 AMBA3 AXI TrustZone 内存适配器（TZMA，BP141）

TrustZone Memory Adapter（TZMA） 用于在 片上静态存储器（如 ROM、SRAM）内划定安全区域。相比为两个世界分别放置独立存储器，更常见也更经济的做法是：放置一颗较大的静态存储器，再按 Secure/Non-secure 分区。TZMA 允许对单个、容量最高 2MB 的静态存储器进行二分：低地址段为 Secure，高地址段为 Non-secure。

分区边界始终按 4KB 对齐，由 TZMA 的 R0SIZE 输入信号控制。该信号既可通过把其接到 TZPC 外设的 TZPCR0SIZE 输出来实现运行时动态配置，也可在综合阶段将其固定（tie-off）为某一值以得到静态分区。

限制：TZMA 不用于动态存储器的分区，亦不支持多个 Secure 分区；若需要此类能力，应使用 TZASC。

---

### 4.1.6 PrimeCell 通用中断控制器（GIC，PL390）

要稳健管理 Secure/Non-secure 中断，底层中断控制器必须阻止 Normal world 修改 Secure 中断源的配置。实现方式要么是单颗控制器在内部支持 TrustZone 分区，要么在系统中放置两颗中断控制器。

GIC 属于前者：单硬件器件即可同时支持 Secure 与 Non-secure 的带优先级中断源。对已被配置为 Secure 的中断线，Normal world 软件的配置修改会被硬件阻止。此外，Non-secure 软件只能在优先级空间的下半区进行配置，以避免拒绝服务（DoS）式的滥用。

> 注：Cortex-A9 MPCore 集成了与 GIC 相同程序员模型的中断控制器，因此无需外置 GIC。其细节见本书 3-15 页“Interrupt handling”。

---

### 4.1.7 PrimeCell 基础设施 AMBA3 TrustZone 保护控制器（TZPC，BP147）

如 AXI-to-APB 桥一节所述，TrustZone Protection Controller（TZPC） 是放置在 APB 总线上的可配置信号控制模块，用于向 SoC 上其它组件提供安全控制信号。

`TZPC` 提供三组通用寄存器 `TZPCDECPROT{2:0}`，每组可控制 SoC 内 8 路信号。此外还包含一个寄存器 `TZPCR0SIZE`，用于向 TrustZone Memory Adapter（TZMA） 提供分区位置控制信号。

`TZPC` 的上电默认状态为：`TZPCDECPROT` 寄存器的所有位均为 0（表示 Secure），`TZPCR0SIZE` 设为 `0x200`，这会使 TZMA 支持的整个 2 MB 内存范围均为 Secure。随后引导代码可根据需要放宽安全设置，将相关组件设为 Non-secure。

# 第 5 章 TrustZone 软件体系结构

本章将探讨若干利用 ARM 安全扩展 的可选软件体系结构。

## 5.1 软件概览

在 SoC 硬件中实现 Secure world 需要有相应的安全软件在其中运行，并利用所存放的敏感资产。

ARM 的安全扩展（Security Extensions）是开放的架构组件，因此任何开发者都可以按自身需求构建定制的 Secure world 软件环境。下面给出在设计 Secure world 软件栈时可参考的一些思路。

> 不同的软件选型对 Secure world 的硬件要求不同。比如，若采用可抢占的独立安全操作系统，就需要安全定时器和具安全感知能力的中断控制器。

### 5.1.1 Secure world 的处理资源

软件架构的整体形态将受到 Secure world 可用处理资源的强烈影响。系统可能提供：

- 一颗支持 TrustZone 的内核（如 ARM1176JZ(F)-S），或
- 一颗专用的 Secure world 处理器（如 Cortex-R4）。

采用两颗物理处理器的设计属于经典嵌入式形态，引入安全扩展对其影响不大；运行在 Secure world 处理器上的软件需自给自足，具备自身的本地运行环境。

预计多数设计会选择支持 TrustZone 的处理器：这通常能为 Secure world 提供更高的软件性能，同时比专用安全处理器占用更少的硅面积。本章余下内容将以这种情形为重点。

### 5.1.2 软件体系结构

在一颗支持 TrustZone 的处理器上，Secure world 软件栈可以有多种架构形态：

- 最复杂的方案是专用的 Secure world 操作系统；
- 最简单的方案是把一组同步调用的安全库放在 Secure world。  
   两者之间还存在大量折中与变体可选。

#### 安全操作系统（Secure operating system）

在安全世界（Secure world）中部署一套专用操作系统是一种复杂但强大的方案。它可以：

- 模拟多个相互独立的安全世界应用的并发执行；
- 支持运行时下载新的安全应用；
- 运行完全独立于普通世界（Normal world）环境的安全任务。

其最极端的形态与在 AMP（非对称多处理）配置下、具有两颗独立物理处理器的 SoC 的软件栈非常相似：每个虚拟处理器上都运行独立的操作系统；两个世界分别利用硬件中断去抢占当前正在运行的世界，从而获得处理器时间。

一种紧密集成的设计可通过通信协议，将安全世界任务与触发这些任务的普通世界线程关联，从而获得类似 SMP（对称多处理） 的诸多优势。例如，安全世界应用可以继承其所服务的普通世界任务的优先级，从而为媒体类应用提供软实时响应能力。

基于操作系统原理的设计有一大优势：可以利用处理器的 MMU 将 Secure 世界 的内存空间划分为多个用户态沙箱。只要 Secure 世界内核实现正确，来自彼此独立的利益相关方的安全任务就能在互不信任的情况下并发执行。内核设计还能强制各安全任务之间的逻辑隔离，防止一个安全任务篡改另一个任务的内存空间。

### 同步库（Synchronous library）

很多场景不需要安全世界操作系统的复杂度。把一组代码作为安全世界的简单库，一次只处理一个任务，就已足够。该库完全由普通世界的 OS 通过软件调用来调度与管理。  
这类系统中，安全世界从属于普通世界，不能独立运行，但因而复杂度更低。

### 折中方案（Intermediate options）

两者之间存在多种折中：

- 例如：设计一个多任务的安全世界 OS，但不配专用中断源，改由普通世界提供虚拟中断。若普通世界 OS 停止提供虚拟中断，确会暴露 DoS（拒绝服务）风险，但在许多应用里这并非严重问题。
- 或者：在原本同步的安全世界库中，用 MMU 对其不同组件做静态隔离。

### 5.2 启动安全系统（Booting a secure system）

在安全系统的整个生命周期中，启动阶段至关重要。许多攻击者会在设备断电时下手，例如把闪存中的安全世界镜像替换为被篡改的版本。如果系统直接从闪存启动而不先验证镜像的真实性，就会暴露在风险之下。

这里的基本原则是：从一个难以被篡改的“信任根”（root of trust）出发，为所有安全世界（以及可能的普通世界）软件建立信任链（chain of trust）。这称为安全启动序列（secure boot）。参见 5-6 页 _Secure boot_。

#### 5.2.1 启动序列（Boot sequence）

支持 TrustZone 的处理器在上电时从安全世界开始运行。这样可以在普通世界软件有机会修改系统之前先完成各类敏感的安全检查。

（图 5-2：一颗支持 TrustZone 的处理器的典型启动序列）

上电后，大多数 SoC 会先执行基于 ROM 的引导程序（ROM bootloader），负责初始化关键外设（如内存控制器），然后再跳转到位于外部非易失性存储（如闪存）中的设备引导程序（device bootloader）。随后，启动流程将继续进入安全世界操作系统，在完成安全世界的各阶段环境初始化后，控制权会交给 Normal world 的引导程序（bootloader）。随后它会启动 Normal world 的操作系统，到此系统即可视为进入运行态。

#### 系统控制协处理器锁定（System control coprocessor lockdown）

若需要更高等级的防护，可利用处理器内的一根输入信号来锁定 CP15 中若干关键的 Secure 世界配置项。当置位 `CP15SDISABLE` 时，即使是 Secure 特权软件也无法再修改部分 Secure 侧的 CP15 设置。

典型做法是：在启动流程中先完成这些敏感设置，再置位 `CP15SDISABLE`，然后把控制权交给 Normal world。

- 系统必须在 `CP15SDISABLE=0`（低）时启动，这样 Secure 启动代码才能按需配置 CP15。
- 改变该信号的方法应仅对 Secure 世界可用；常见做法是使用锁存式控制电路，只能在整机复位时把该信号复位为低。

### 5.2.2 安全启动（Secure boot）

安全启动方案在 Secure 世界启动流程的每个阶段加入密码学校验，以确认即将执行的所有 Secure 世界镜像的完整性，阻止任何未授权/被篡改的软件运行。（必要时也可对 Normal world 做同样处理。）

#### 密码签名协议（Cryptographic signature protocol）

最合适的协议通常基于公钥签名算法，如 RSA-PSS。流程如下：

- 可信厂商用其私钥（PrK）对准备发布的代码生成数字签名，并连同二进制镜像一起下发到设备。
- 设备内置该厂商的公钥（PuK），用于在启动时验证镜像未被篡改，且确由该可信厂商提供。
- PuK 不必保密，但必须以不可被攻击者替换的方式安全存储在设备内（否则攻击者可换成其自有 PuK 来放行恶意代码）。

#### Chain of trust（信任链）

安全启动通过信任链来实现：从一个默认可信的组件开始，之后的每个组件在执行前都必须被认证。链条在各阶段的所有权可以变更——例如，用设备 OEM 的公钥（PuK）验证第一阶段引导程序；而安全世界 OS 的镜像中又可内置第二把 PuK，用于验证它所加载的安全应用。

除非你的设计可以完全排除 shack 攻击（低预算硬件攻击），否则信任根（root of trust）必须位于 片上 ROM（on-SoC ROM）。SoC ROM 是系统中无法通过简单重编程就被轻易修改或替换的唯一组件。

信任根所用 PuK 的存储是个难点：把 PuK 烧在 on-SoC ROM 意味着所有设备都用同一把 PuK，一旦 PrK（私钥）被盗或被逆向，就会遭遇 class-break（批量破解）攻击。为降低此风险，可在制造阶段用 片上一次性可编程（OTP） 硬件（如多晶硅熔丝）为每颗 SoC 写入唯一值，从而让同一机型内部也能持有多把不同 PuK。

> OTP 会占用不小的硅面积，可用位数通常有限。而 RSA PuK 往往 >1024 位，通常放不下。好在 PuK 不需要保密，它可存片外；只要在 OTP 中存一份 PuK 的加密哈希（如 SHA-256 的 256 位）。启动时先校验 PuK 的哈希，即可确认 PuK 自身未被替换。

---

#### On-SoC Secure world 或 Off-SoC Secure world

对抗 shack 攻击最简单有效的做法：让安全世界的代码与数据只在片上存储器（on-SoC）中执行与驻留。只要不出 SoC 封装，窥探/篡改的难度就会显著上升（攻破封装远比探针夹在 PCB 走线或引脚上难）。

安全启动代码通常负责把镜像装入 on-SoC 存储器。认证步骤的先后次序至关重要，否则会留下攻击窗口。假设当前运行代码与所需的哈希均已在安全的 on-SoC 内存中，那么待验证的二进制或 PuK 应当先复制到安全位置，再进行密码学校验。  
若设计成先验证镜像、再把它复制到安全内存，将存在时间窗口：攻击者可在校验结束与复制开始之间篡改镜像，从而绕过保护。

## 5.3 监控器（Monitor）模式软件

监控器模式软件在设计中的角色，是充当稳健的“门卫”，管理 Secure / Non-secure 两种处理器状态之间的切换。在多数设计里，它的功能类似传统 OS 上下文切换：确保离开的那个“世界”的状态被安全保存，并进入的新“世界”的状态被正确恢复。

来自 Normal world 的进入监控器是严格受控的：只能通过中断、外部异常（external abort），或显式 SMC 指令触发。来自 Secure world 的进入更灵活：除具备 Normal world 可用的异常路径外，还可直接写 CPSR 进入。

由于监控器负责两世界之间的接口，其本身是安全关键组件。为提升稳健性，建议监控器代码在关中断的状态下执行；把监控器写成可重入会增加复杂度，通常得不偿失。

---

### 5.3.1 上下文切换（Context switching）

如前所述，监控器的首要职责是为两世界共用的资源做上下文切换。任何由监控器保存的安全状态都应保存在 Secure 内存中， 防止 Normal world 篡改。

具体每次切换需要保存/恢复哪些内容，取决于硬件设计与跨世界通信的软件模型。典型包括：

- 全部通用寄存器（general purpose ARM registers）
- 协处理器寄存器（如 NEON / VFP）
  > 仅当该协处理器 在两世界均会使用 时才需要切换
- CP15 中与世界相关的处理器配置状态

#### 硬件异常：IRQ、FIQ、external abort

当处理器被配置为把这些异常（IRQ/FIQ/外部取/数异常）陷入监控器时，被打断时的上下文状态不确定。  
因此通常需要完整切换全部状态；除非能采用惰性（lazy）上下文切换（见 5-10）。

#### 软件异常：SMC

很多情况下，设计会把 SMC 指令当作简单的跨世界让渡（yield），其效果类似于上面的硬件异常，会触发完整上下文切换。  
但有时希望 SMC 在部分寄存器中携带消息载荷，这时就不适合做完整切换。  
借助 SMC 触发的切换与两世界共享内存（World-shared memory），可以构建高效的软件通信协议。

#### 惰性上下文切换（Lazy context switching）

部分通过 ARM 协处理器接口连接的模块（如 VFP/NEON），支持惰性上下文切换：只有确有需要时才保存其上下文，而不是在每次 OS 上下文切换或 TrustZone 世界切换时都保存。由于 VFP/NEON 的状态体量较大，惰性切换能显著降低平均切换开销。  
在 TrustZone 中实现惰性切换的方法：Secure world 可通过 CP15 的 NSACR（Non-Secure Access Control Register）中的位设置，屏蔽 Normal world 对各协处理器接口的访问。当 Normal / 用户态 软件尝试访问被 NSACR 标为 Secure 的协处理器时，会触发未定义指令异常；Normal world 内核捕获异常后，调用 SMC 请求监控器完成所需协处理器上下文切换。一旦切换完成，监控器即可通过 NSACR 放开该协处理器对 Non-secure 的访问，并返回给 Normal world 的异常处理程序。

> 许多 Secure world 实现并不需要浮点或 SIMD 运算。若 Secure world 不使用协处理器，系统启动代码即可直接放开全部协处理器给 Non-secure 使用；这类场景不存在敏感协处理器状态，监控器也无需切换其上下文。

---

## 5.3.2 中断模型——监控器侧需求

在 3-11 节“安全中断”模型中，IRQ 配为 Normal world 中断、FIQ 配为 Secure world 中断。为此，在世界切换时，Monitor 软件需要对内核做相应配置。

该模型建议：若中断发生时处理器已处于对应的世界，硬件不将异常路由到 Monitor 模式，而是直接跳转到本世界的异常向量表。这样可避免一次进入 Monitor 的开销，并简化 Monitor 的实现。

> 若设计为所有异常都路由到 Monitor 模式，则会跳转到 Monitor 模式的向量表中相应入口；此时内核处于 Monitor 模式，而不是各自世界的异常模式。

CP15 的 SCR（Secure Configuration Register）包含控制项，用于决定 IRQ/FIQ/外部异常（external abort）是否路由到 Monitor 模式。要实现上述模型，Monitor 在每次世界切换时都需修改 SCR：

- 切换到 Normal world：清 `SCR.IRQ`，置 `SCR.FIQ`
- 切换到 Secure world：置 `SCR.IRQ`，清 `SCR.FIQ`

> 这只是 TrustZone 处理器中使用中断的多种可能模型之一。

---

## 5.3.3 中断时延影响（Interrupt latency impact）

凡是处理中断需要切换世界的设计，监控器都会进入关键路径，影响最坏情况下的中断时延。与常用于深度嵌入场景的 R/M-profile 不同，部署在 A-profile 上的应用类软件通常不强调极低时延；但仍需把监控器带来的附加时延计入，确保时序约束不被违反。

监控器增加的开销可能不只一次世界切换的成本：例如，若处理器刚进入监控器时发生了中断，它会先经过监控器再处理；若处理中断需要切回另一世界，还要再经过第二次监控器切换。

为最小化中断时延，应把监控器用到的代码与数据放在靠近内核的高速存储器：

- 对 ARM1176JZ(F)-S，可放在 TCM
- 无 TCM 的系统，可放在锁定（lock-down）的 L2 缓存行或片上高速 SRAM

示例：中断时延的增加量

- ARM1176JZ(F)-S
  - 监控器代码/数据位于 TCM
  - 上界约 200 周期/次切换，往返 400 周期
  - 400 周期 @ 300 MHz ≈ 1.3 µs
- Cortex-A8
  - 监控器代码/数据位于锁定的 L2
  - 约 1200 周期/次切换，往返 2400 周期
  - 2400 周期 @ 600 MHz ≈ 4 µs

> 注意  
> 总中断时延还包含 Normal world 与 Secure world 自身的软件开销，以及系统层面（如外部存储性能）的影响，上述数字未计入这些部分。  
> 作为对比：在 ARM1176JZ(F)-S 上、两级缓存开启、无 Secure world 的情况下，一个 Linux 驱动看到的中断时延约 5000 周期——主要来自 OS 自身的开销。

## 5.4 安全软件与多处理器系统

一些希望使用安全执行环境的设计会基于 ARM 多处理器（如 Cortex-A9 MPCore）。这类系统可在多颗处理器上并行执行线程，获得更高的软件性能，适合媒体编解码等计算密集型任务。

对 Secure world 的软件架构师而言，一个关键决策是——安全世界将如何利用多处理器？

多数安全系统力求软件简单，因为越简单越不易产生暴露漏洞的 Bug。真正的多线程会引入与时序敏感相关的复杂性，测试困难。因此，很多 Secure world 实现会选择按单处理器方式运行安全世界，很少或不使用 SMP 特性，即使 Normal world 正在以完整 SMP 模式运行。

### 5.4.1 安全世界的处理器“亲和性”（processor affinity）

如果选择让安全世界不进行多处理，那么需要让 SMP 的 Normal world 与 Secure world 之间的通信可被同步协调。

一种做法是把 Secure world 固定绑定到某一特定处理器。这会使安全中断路由更简单，但也意味着安全世界会占用该核的时间，Normal world 的线程调度可能因此难以负载均衡。在这种设计里，与安全世界通信的 Normal world 驱动通常需要通过核间通信（IPC/IPI）把对安全世界的请求路由到正确的处理器。此外，未被安全世界占用的那些处理器上的 Monitor 软件必须阻止 Normal world 触发恶意的世界切换。  
该体系结构如图 5-3（5-14 页）所示，安全世界只在 CPU0 上运行。
![image.png|600](https://pic.lllincx.cn/20251107155118782.png)

另一种做法是允许安全世界在多颗处理器之间迁移，但限制为任意时刻仅在一颗处理器上执行。这样做让安全世界更高效：它可以与发起请求的 Normal world 应用运行在同一核，同时也方便 Normal world 做负载均衡；但其代价是如何把安全中断路由到需要的处理器会更复杂。

### 5.4.2 安全世界的中断使用

在确定安全世界如何利用 SMP 之后，还需决定如何集成安全中断源。

若架构将安全世界固定在单一处理器上，则中断路由相对直接：为该处理器配置中断控制器的每核接口控制寄存器，按软件设计需要，使安全中断触发 FIQ 或 IRQ 异常。

多处理器系统中，单个处理器的中断路由模型详见 5.3.2（“中断模型——对 Monitor 的要求”）。如该节所述，负责处理安全或非安全中断的处理器上的 Monitor 软件需要能够把中断路由到相应世界，由正确的异常处理程序接管。

在一个 SMP 系统中，如果安全世界只在集群内的单一处理器上执行，那么未运行安全世界的软件的其他处理器上，FIQ 可以留作 Non-secure 中断使用。为防止硬件把这些中断路由到安全世界，这些处理器上运行的安全引导程序或 Monitor 必须确保 CP15 的 SCR（Secure Configuration Register）被正确配置。

> 若安全世界仅在单一处理器上执行，通常需要让其他处理器上的 Monitor 软件对 Normal world 试图通过 SMC 指令、（FIQ/IRQ）中断或外部异常来发起的世界切换予以拒绝。

# 5.5 TrustZone API

为推动安全解决方案的开发，ARM 定义了一套标准化软件 API——TrustZone API（TZAPI）。该 API 规定了富操作环境（Normal world）下运行的客户端应用与安全环境（Secure world）交互所用的软件接口。

该 API 的核心是通信 API：支持客户端向安全服务发送命令请求，并与所连接的服务高效交换数据。该通信接口旨在配合 World-shared memory（世界共享内存） 原则，实现高性能的批量数据传输。

API 的次要功能包括：允许 Normal world 的客户端应用向安全服务进行自身认证；查询已安装服务的属性；以及允许受信任的 Normal world 代码在运行时下载新的安全服务。

> Note  
> 通信 API 同时支持同步与（可选的）异步调用约定，以适配嵌入式设备上常见的各类 Normal world 操作系统。

虽然 TrustZone API 面向支持 TrustZone 的处理器，并尽力利用如世界共享内存等硬件能力，但其设计可移植到几乎任何安全环境实现上。比如，运行可扩展安全框架的智能卡也可以实现 TZAPI。在这些非 TrustZone 系统中，TZAPI 的世界共享内存语义可能需要通过拷贝来实现，但总体上仍具可移植性。

## 5.5.1 API 的获取

鉴于缺乏统一软件标准曾经阻碍了安全软件生态的发展，ARM 将 TrustZone API 以公开规范形式发布，任何软件开发者都可免费下载并使用，将其作为对接底层安全方案的接口。

TrustZone API 可从 ARM 官网免费获取：`http://www.arm.com/TrustZone`（详情参见该页面）。
